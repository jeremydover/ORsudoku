Supported Constraint List
=========================
159 (see Indexing)
Alternate Digits
Anti-King
Anti-Knight
Arrows
Average Lines
Battenburg
Battlefield
Between Lines
Block Cages
Cell Transform Sudoku
Chinese Whispers Lines - see Whispers Lines
Clone Regions
Consecutive Quads
Corner/Edge Clues
Count the Odds Lines
Difference Pairs - see Kropki and Kropki Pairs
Digit Count Cages
Disjoint Groups
Double Arrows - see Arrows
Double or Nothing Sudoku - see Cell Transform Sudoku
Doubler Sudoku - see Cell Transform Sudoku
Doubling Lines
Dutch Whispers Lines - see Whispers Lines
Entropic Lines
Entropki Dots (same/different entropy classes)
Entropy (see Global Entropy)
Entropy Battenburg (on a 2x2, no pair of same entropic cells are adjacent)
Entropy Quads (partial Entropy, asserts Entropy on an individual 2x2)
Even-Odd
Extra Regions - see irregular Sudoku
Fortress
Friendly Cells
Genetics
German Whispers Lines - see Whispers Lines
Given Digits
Global Entropy
Global Whispers (Dutch, et. al.)
Gurth's Symmetric Placement (GSP)
Indexing
Irregular Sudoku
Isotopes
Japanese Sum Sudoku
Keypad King Lines
Keypad Knight Lines
Killer Cages (repeating and non-repeating)
Kropki (see Kropki Pairs)
Kropki Pairs
Little Killer
Lockout Lines
Look-and-Say Cages - see Zones
Magic Squares
MaxAscending
Median Cages
Min-Max
Modular Lines
More-Odd-Than-Even/More-Even-Than-Odd Cages
Nabner Lines
Negator Sudoku - see Cell Transform Sudoku
Neighbor Sums
Next-To-Nine
Non-Consecutive
Numbered Room
Outside Clues
Palindrome Lines
Parindrome Lines - see Palindrome Lines
Parity Dots
Parity Lines (alternating parity along line)
Pencilmarks
Pointing Arrows - see Arrows
Position Sums
Quadruple
Quad Max Arrows
Quad Max Values
Quad Sums (one digit on a quad is the sum of the three others)
Ratio Pairs - see Kropki and Kropki pairs
Region Sum Lines (sum of all cells along a line in a region is fixed)
Region Segment Sum Lines - see Region Sum Lines
Renban Lines
Rossini Clues
Run-On Renban Lines - see Renban Lines
Samurai Sudoku
Sandwich Sums
Shift Lines
Slow Thermometers (see Thermometers)
Sum Dots (see Killer Cages)
Thermometers
Unicorn Digits
Weak Palindrome Lines
Windoku
X-Kropki
XSudoku
X-Sum
XV (see XV Pairs)
XV Pairs
XVXV
Zones

Some Notes on Data Structures
-----------------------------
All cells are indexed as tuples, e.g. (4,6), per the following array:

----------------------------
|11|12|13|14|15|16|17|18|19|
----------------------------
|21|22|23|24|25|26|27|28|29|
----------------------------
|31|32|33|34|35|36|37|38|39|
----------------------------
|41|42|43|44|45|46|47|48|49|
----------------------------
|51|52|53|54|55|56|57|58|59|
----------------------------
|61|62|63|64|65|66|67|68|69|
----------------------------
|71|72|73|74|75|76|77|78|79|
----------------------------
|81|82|83|84|85|86|87|88|89|
----------------------------
|91|92|93|94|95|96|97|98|99|
----------------------------

When a constraint requires a cell or list of cells, they can be input in one of three ways:
1. Explicitly as a tuple, e.g., (5,6)
2. As a string, e.g., '85'
3. As an integer, e.g., 16.

Note: The non-tuple cell inputs WILL break on boards larger than 9x9. However, since 9x9 is by far the most popular use case, these shortcuts are worth having.

Quadruples are indexed similarly, from 11 to 88:

-------------------------------------
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---1,1-1,2-1,3-1,4-1,5-1,6-1,7-1,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---2,1-2,2-2,3-2,4-2,5-2,6-2,7-2,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---3,1-3,2-3,3-3,4-3,5-3,6-3,7-3,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---4,1-4,2-4,3-4,4-4,5-4,6-4,7-4,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---5,1-5,2-5,3-5,4-5,5-5,6-5,7-5,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---6,1-6,2-6,3-6,4-6,5-6,6-6,7-6,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---7,1-7,2-7,3-7,4-7,5-7,6-7,7-7,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---8,1-8,2-8,3-8,4-8,5-8,6-8,7-8,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
-------------------------------------

Edge constraints are indexed by the top- or left-most cell in the pair of adjacent cells. An additional parameter hv is provided to determine whether the pair is horizontal or vertical. The class variables Horz and Vert can be used for this designation. 

Alternate Digits
----------------
If a puzzle does not have a 1-9 digit set (0-8 being the most common alternative), then an alternate digit set can be added by including the digitSet parameter when instantiating the puzzle, e.g.,
p = ORsudoku.sudoku(boardSizeRoot,digitSet={0,1,2,3,4,5,6,7,8})

Anti-King
---------
setAntiKing(): applies the anti-king constraint to the whole puzzle

Anti-Knight
-----------
setAntiKnight(): applies the anti-knight constraint to the whole puzzle
  
Arrows
------
setArrow(inlist): creates an arrow constraint
  inlist: a list of cells along arrow, where the first element of list is the circle
  
setDoubleArrow(inlist): creates a double arrow constraint - sum of cells between the endpoint equals the sum of the endpoints
  inlist: a list of cells along arrow, where the first element of list is the circle
  
setPointingArrow(list): creates a pointing arrow, which is both a regular arrow, and whose other end points (as determined by the last two cells) at another copy of the sum
  list: a list of cells along arrow, where the first element of list is the circle
  
setMultiDigitSumArrow(list,n): creates an arrow where the sum is multi-digit, interpreted base 10
  list: a list of cells along the arrow where the first n elements are in the circle, listed from most-significant to least significant
  n: the number of digits in the circle
  
Average Lines
-------------
setAverageLine(inlist): creates an average line, where the first cell in the list is the average (arithmetical mean) of the cell values in the list
  inlist: a list of cells specifications
  
Battenburg
----------
setBattenburg(cell): creates a Battenburg constraint (no cells on the quad with the same parity share an edge)
  cell: a single cell specification, e.g., 13,'25',(4,7)
  
setBattenburgArray(list): creates multiple Battenburg constraints
  list: a list of cell specifications
  
setAntiBattenburg(cell): creates a negative Battenburg constraint (the Battenburg condition does NOT hold)
  cell: a single cell specification, e.g., 13,'25',(4,7)
  
setAntiBattenburgArray(list): creates multiple negative Battenburg constraints
  list: a list of cell specifications

setBattenburgNegative(): specify that all cells not specifically designated with Battenburgs do NOT satisfy the Battenburg constraint

Battlefield
-----------
setBattlefield(row,col,rc,value): inplements a Battlefield constraint in a row or column
  row,col: The coordinates of a cell on either end of the row/column
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: summarized from Realshaggy: Consider the first x and last y cells of a row or column where x is the value of the first and y the value of the last cell. value is the sum of the digits where these groups overlap or the sum of the digits between these groups.
  
Between Lines
-------------
setBetweenLine(list): creates a between line constraint
  list: a list of cell specifications
  
Block Cages
-----------
setBlockCage(list,values): creates a block cage, that is an list of cells and a list of values, such that those values cannot appear within the cage
  list: list of cell specifications
  values: a list of values...if unambiguous the punctuation can be omitted, so that [1,2,3,9] and 1239 can both be entered as a value list

Cell Transform Sudoku
---------------------
Inspired by the doubler rules invented by zetamath. Grid is as normal, but one cell in each row, column in region is doubled when used in other constraints. To model cell transform contraints requires use of a different class:

p = ORsudoku.cellTransformSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  All three parameters are optional:
  canRepeatDigits: if canRepeatDigits is True, then the constraint that the base digits of all transformed cells need to be distinct is waived. Default is False
  irregular and digitSet are settable just like the regular Sudoku class

By default the cellTransformSudoku class just implements Doubler Sudoku. Doubler Sudoku can also be initialized with:
p = ORsudoku.doublerSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)

To implement other rulesets, one needs additional classes:

negatorSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  Just like doubler Sudoku, but the designated cells are negated, not doubled
  
doubleOrNothingSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  The designated cells are either doubled, or count as zero, in other constraints. Note: this behavior is consistent; each cell is either doubled or nothing, and does not vary depending on which constraint is applied.
  
affineTransformSudoku(boardSizeRoot,ratio,shift,canRepeatDigits,irregular,digitSet)
  The parameters ratio and shift are required, and the transformed digits count as ratio*value+shift to all constraints.
  Doubler Sudoku is the same as affineTransformSudoku(3,2,0)
  Negator Sudoku is the same as affineTransformSudoku(3,-1,0)

Clone Regions
-------------
setCloneRegion(list): creates a set of regions that are clones of each other, i.e., the same digit appears in the ith position for each i
  list: a list OF LISTS of cell specifications
  
Consecutive Quads
-----------------
On a quad, a black dot indicates at least two pairs of cells in the quad, including diagonals, have consecutive digits, while a white indicates exactly one pair.

setConsecutiveQuadWhite(cell):	set a single white consecutive quad dot
	cell: single cell specification
	
setConsecutiveQuadWhiteArray(list): set multiple white consecutive quad dots
	list: a list of cell specifications
	
setConsecutiveQuadBlack(cell):	set a single black consecutive quad dot
	cell: single cell specification
	
setConsecutiveQuadBlackArray(list): set multiple black consecutive quad dots
	list: a list of cell specifications
	
setConsecutiveQuadArray(list): set multiple black/white consecutive quad dots
	list: a list of extended cell specifications, containing row/col, plus an indication of whether the dot is white (0) or black (1). Use the Black and White class variables for surety.
	
setAntiConsecutiveQuad(cell): asserts that there are no consecutive pairs of digits amongst the 6 pairs of digits in the quad
	cell: cell specification
	
setAntiConsecutiveQuadArray(list): assert multiple anti-consecutive quad conditions
	list: a list of cell specifications
	
setConsecutiveQuadNegative(): assert that all possible dots are given, so places without dots have no consecutive pairs

Corner/Edge Clues
-----------------
setCornerEdge(box,ce,valueList): sets a list of values that must appear in a corner or on an edge of a BOX (not region)
  box: integer denoting box, upper left corner is 1, to its right is 2, etc.
  ce: determines whether clue is for corners or edges. 0 or class variable Corner for corner, 1 or class variable Edge for edge
  valueList: list of cell values for which to assert placement

Count the Odds Lines
--------------------
setCountTheOddsLine(list): set a count the odds line, where the digit in the first cell of the line counts the number of odd digits on the rest of the line; pioneered by clover!
  list: list of cell specifications

Digit Count Cages
-----------------
setDigitCountCage(inlist,value): asserts that value is the number of distinct digits appearing in the cage; pioneered by clover!
  inlist: list of cell specifications
  value: integer counting number of distinct digits

Disjoint Groups
---------------
setDisjointGroups(): sets the global disjoint groups constraint

Doubling Lines
--------------
setDoublingLine(list): creates a doubling line constraint: every digit appears exactly twice on the line
  list: a list of cell specifications

Entropic Lines
--------------
setEntropicLine(list): creates an entropic line constraint
  list: a list of cell specifications
  
Entropki Dots
-------------
Entropki dots are placed like Kropki dots, but white dots indicate the adjacent cells are of different entropic ranks, while black dots indicate the adjacent cells are of the same entropic rank.

setEntropkiWhite(cellHV): creates a white Entropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setEntropkiBlack(cellHV): creates a black Entropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setEntropkiWhiteArray(list): creates multiple white Entropki dots
  list: list of cellHV specifications, see setEntropkiWhite

setEntropkiBlackArray(list): creates multiple black Entropki dots
  list: list of cellHV specifications, see setEntropkiBlack
  
setEntropkiArray(list): creates multiple Entropki dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setEntropkiWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
Entropy Battenburg
------------------
setEntropyBattenburg(cell): creates an entropy Battenburg constraint (no cells on the quad of the same entropic rank share an edge)
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setEntropyBattenburgArray(list): creates multiple entropy Battenburg constraints
  list: a list of cell specifications
  
setAntiEntropyBattenburg(cell): creates an anti-entropy Battenburg constraint (some pair of adjacent cells on the quad have the same entropic rank)
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiEntropyBattenburgArray(list): creates multiple anti-entropy Battenburg constraints
  list: a list of cell specifications
  
setEntropyBattenburgNegative(): specify that all cells not specifically designated with entropy Battenburgs do NOT satisfy the entropy Battenburg constraint

Entropy Quads
-------------
setEntropyQuad(cell): creates an entropy constraint (all three entropic ranks must appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setEntropyQuadArray(list): creates multiple entropy quad constraints
  list: a list of cell specifications
  
setAntiEntropyQuad(cell): creates an anti-entropy constraint (all three entropic ranks cannot appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiEntropyQuadArray(list): creates multiple anti-entropy quad constraints
  list: a list of cell specifications
  
setEntropyQuadNegative(): specify that all cells not specifically designated with entropy quads do NOT satisfy the entropy quad constraint, i.e., some entropic rank will be missing around each quad which is not an entropy quad

Even-Odd
--------
setEven(cell): asserts the cell value is even
  cell: single cell specification

setOdd(cell): asserts the cell value is odd
  cell: single cell specification
  
setEvenOdd(cellEO): asserts the parity of a cell
setOddEven(cellEO): asserts the parity of a cell
  cellEO: a cell specification augmented with an even odd specification. Tuple specification may use the Even and Odd variables, e.g. (5,8,p.Odd). Shorthand is possible, using 0 for even and 1 for odd. Thus 581 is an alternative specification for the same assertion.
  
setEvenArray(list): create multiple even constraints
  list: list of cell specifications
  
setOddArray(list): create multiple odd constraints
  list: list of cell specifications
  
setEvenOddArray(list): create multipl parity constraints
setOddEvenArray(list): create multipl parity constraints
  list: list of cellEO specifications; see setEvenOdd
  
Fortress
--------
setFortress(list): creates a Fortress constraint on a group of cells
  list: list of cell specifications
  
Friendly Cells
--------------
setFriendly(cell): creates a friendly cell, i.e., one whose value matches one or more of its row, column, or box number
	cell: single cell specification
	
setFriendlyArray(list): set multiple friendly cells
	list: list of cell specifications
	
setUnfriendly(cell): creates a cell that is not friendly, i.e., its value does NOT match row, column or box
	cell: single cell specification
	
setUnfriendlyArray(list): set multiple unfriendly cells
	list: list of cell specifications

setFriendlyNegative(): assert a negative constraint, namely that cells not marked friendly are NOT friendly

Genetics
--------
setGenetic(list): applies a genetic constraint to the cells: daughter must inherit parity/entropic rank from parents, and must inherit at least one from each
	list: a list of three cell specifications - first two are parent cells, last is daughter cell specification

setGeneticArray(list): applies genetic constraint to multiple specification lists
	list: a list of lists of cell specifications, where each element of the list is formatted per the setGenetic guidelines
 
Given Digits
------------
setGiven(cellVal): set the value in a particular cell
  cellVal: an extended cell specification that includes the value to be set. Shorthand is possible.
    Example: 289, '289' and (2,8,9) all designate a 9 given in row 2, column 8
	
setGivenArray(list): set multiple given digits
  list: a list of cellVal specifications; see setGiven
  
Global Entropy
--------------
setGlobalEntropy(): assert the Entropy condition on all quads. Effectively the same as setting entropy quads on all quads; see set EntropyQuad

Global Whispers
---------------
setGlobalWhispers(n=4): assert the global whispers constraint: every cell has at least one neighbor with which it has a difference of at least n. The default for n is 4

Gurth's Symmetric Placement
---------------------------
Asserts that the the grid has symmetry based on 180 degree rotation plus some permutation of the digits.
setGSP(pairs): assert the GSP constraint
  pairs: a list of lists of pairs of digits whose placement implements the symmetry. Default is pairs that sum to the grid size + 1, e.g. (19,28,37,46). Computationally, this list does NOT need to be complete, so one could use this to assert that everywhere a 1 appears, a 7 appears in the rotational symmetric position, and leave it at that. Don't know if that makes for an interesting puzzle though.

Indexing (159)
--------------
****NOTE****
There is something about the indexing code that the underlying SAT solver does not like. Be wary of trying to gather
all solutions.

setIndexRow(row,neg=False,inlist=[]): set an index row, namely one which indicates the position of the digit corresponding to the row within some subset of columns
  row: the row (1-9) used as an index. By default, all column positions index
  neg (optional): if a column position is indicated as not indexing, then position indicate specifically does NOT indicate the position of the digit. Default is False.
  inlist (optional): a list of which column positions (1-9) are indexing, with columns not in the list NOT indexing
  Example: If we call setIndexRow(5,True,[1,2,3,4,5,6,7,8]), then in all but the rightmost column, the entry in row 5, column X indicates which row contains a 5 in that column. So if 5,1 is a 2, then 2,1 must be 5. In the rightmost column, the 5 CANNOT appear in the row indicated by the entry in row 5. Specifically if 5,9 is a 3, then the entry in 3,9 CANNOT be a 5.

setIndexColumn(row,neg=False,inlist=[]): set an index column. See setIndexRow for details of the mechanics
  Example: The traditional 159 ruleset is implemented with the calls:
  setIndexColumn(1)
  setIndexcolumn(5)
  setIndexColumn(9)
  
Irregular Sudoku
----------------
Note: for ALMOST all intents and purposes, regions are no different from killer cages of size 9. But regions are respected by regions sum lines, where cages are not.

To implement an irregular Sudoku puzzle, call the puzzle constructor with the irregular flag set, e.g.,
p = ORsudoku.sudoku(boardSizeRoot,irregular=True)

setRegion(list): creates an Irregular Sudoku region
	list: list of cell specifications
	
set Regions(list): create multiple irregular Sudoku regions
	list: list OF LISTS of cell specifications

Isotopes
--------
Note: this constraint is only accurate for 9x9 puzzles with boxes...created by rockratzero
setRRZRotor(): asserts that if any two boxes have the same center cell, then the other digits in each box appear in the same order, modulo rotation

Japanese Sum Sudoku
-------------------
To model a Japanese Sum Sudoku puzzle, you must use the class japaneseSumSudoku, e.g.

p = ORsudoku.japaneseSumSudoku(boardSizeRoot)

Note: The Japanese Sum Sudoku class now supports the countSolutions method. HOWEVER, it uses a huge number of Boolean variables that can quickly create exponentially many solutions which are fundamentally the same (i.e. same digits). Recommend only using this for final testing to determine if a puzzle solution is unique.

In this class, you can use the following method:
setJapaneseSum(row,col,rc,value): sets a Japanese sum constraint
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: A list of values representing the sums in a clue. Use 0 to stand-in for an unshaded group with an indeterminate sum, i.e. to replace a ?

Keypad King Lines
-----------------
setKeypadKingLine(list): creates a keypad king line constraint (adjacent digits must be a king's move apart on a telephone keypad). Designed by Zegres
  list: a list of cell specifications
  
Keypad Knight Lines
-------------------
setKeypadKnightLine(list): creates a keypad knight line constraint (adjacent digits must be a knight's move apart on a telephone keypad). Designed by Zegres.
  list: a list of cell specifications
  
Killer Cages
------------
setCage(list,value): creates a killer cage with all cell values distinct
  list: list of cell specifications indicating the cells in a killer cage
  value (optional): if given, indicates the sum of the digits in the cage
  Note: sum dots can be implemented computationally with a killer cage, since this method does not require any particular relationship amongst the cells.
  
setRepeatingCage(list,value): creates a killer cage where values may repeat
  list: list of cell specifications indicating the cells in a killer cage
  value: indicates the sum of the digits in the cage
  
Kropki and Kropki Pairs
-----------------------
setKropkiWhite(cellHV): creates a white Kropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiBlack(cellHV): creates a black Kropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiWhiteArray(list): creates multiple white Kropki dots
  list: list of cellHV specifications, see setKropkiWhite

setKropkiBlackArray(list): creates multiple black Kropki dots
  list: list of cellHV specifications, see setKropkiBlack
  
setKropkiArray(list): creates multiple Kropki dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setKropkiWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
setAntiKropki(cellHV): asserts that the digits are neither consecutive or in a 2-to-1 ratio by default...uses kropkiDifference and kropkiRatio if these have been changed
	cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V.

setAntiKropkiArray(list): creates multiple anti-Kropki constraints
  list: list of cellHV specifications, see setKropkiWhite
  
setKropkiNegative(): implements true Kropki rules with a negative constraint

To change the values used for difference for white dots, and ratio for black dots, you can use the following methods:
setKropkiDifference(value)
setKropkiRatio(value)

The values can be reset to their defaults by calling them with no argument. All dots added subsequently to these calls will use the new values, without changing constraints already entered. HOWEVER, if a negative constraint is applied, it will ALWAYS use the final set value of these two variables to apply the negative constraint against.

Little Killers
--------------
setLittleKiller(row1,col1,row2,col2,value): sets a little killer diagonal constraint
  row1,col1: the cell spec of the first cell in the little killer diagonal, next to the clue
  row2,col2: the cell spec for the second cell in the diagonal (this seemed easier than some arbitary spec to define diagonals)
  
Lockout Lines
-------------
setlockoutLine(list): creates a lockout line constraint
  list: a list of cell specifications
  
Magic Squares
-------------
setMagicSquare(cell): creates a magic square with given cell the upper left corner
  cell: single cell specification

Max Ascending
-------------
setMaxAscending(row,col,rc,value): sets a max ascending constraint, specifying the longest consective run of increasing digits in the row/col, looking from the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the length of the longest run of increasing digits in the row/col
  
Median Cages
------------
setMedianCage(list,value): sets the median value in the region (which must appear in the region)
	list: list of cell specifications
	value: target median value

Min-Max
-------
setMinCell(cell): assert a cell is smaller than all orthogonally adjacent cells
  cell: single cell specification
  
setMaxCell(cell): assert a cell is larger than all orthogonally adjacent cells
  cell: single cell specification
  
setMinArray(list): set multiple minimum cells
  list: list of cell specifications
  
setMaxArray(list): set multiple maximum cells
  list: list of cell specifications
  
setMinMaxCell(cellMM): set a minimum or maximum constraint
setMaxMinCell(cellMM): set a minimum or maximum constraint
  cellMM: an extended cell specification which adds the minmax parameter. All parameters can be given positionally, or in a tuple, and these can use the Min and Max variables for the minmax specification. Shorthand is possible, appending 0 to a cell spec to indicate a minimum and 1 to indicate a maximum.
  
setMinMaxCellArray(list): set multiple min/max constraints
setMaxMinCellArray(list): set multiple min/max constraints
  list: list of cellMM specifications; see setMinMaxCell
  
Modular Lines
-------------
setModularLine(list): creates a modular line constraint
  list: a list of cell specifications
  
More-Odd-Than-Even Cages
------------------------
A MOTE cage has more odd digits than even digits, and a METO cage is the reverse

setMOTECage(list): set a MOTE cage
	list: list of cell specifications

setMETOCage(list): set a METO cage
	list: list of cell specifications

Nabner Lines
------------
setNabnerLine(inlist): assert that there are no two digits lying on the line are the same or consecutive
	inlist: list of cell specifications

Neighbor Sums
-------------
setNeighborSum(cell): asserts a cell is the sum of its orthogonally adjacent neighbors
	cell: single cell specification
	
setNeighborSumArray(list): asserts multiple neighbor sum constraints
	list: list of cell specifications
	
Note: setNeighbourSum and setNeighbourSumArray aliases are supported

Next-to-Nine
------------
setNextToNine(row,col,rc,values,digit): given a set of 1/2 digits on a row/column, these digits must appear in next to the nine in that row/column
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: A list of values to go next to 9; if only one value is given it may be given as an integer
  digit (optional): defines which digit is the one the clued digits must appear next to...defaults to 9

Non-Consecutive
---------------
setNonConsecutive(): sets the global non-consecutive cells constraint

Numbered Rooms
--------------
setNumberedRoom(row,col,rc,value): sets a numbered room constraint
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell
  
Outside Clues
-------------
setOutside(row,col,rc,valueList): provides a set of values on a row or column that must appear in that row/column in the first box (region for irregular sudoku) appearing next to the clue
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  valueList: a list of values to be placed

Palindrome Lines
----------------
setPalindromeLine(list): creates a palindrome line constraint
  list: a list of cell specifications
  
setParindromeLine(list): creates a parindrome line constraint, where only parity has to match 
  list: a list of cell specifications
  
Parity Dots
-----------
Parity dots are placed like Kropki dots, but white dots indicate the adjacent cells are of different parities, while black dots indicate the adjacent cells are of the same parity.

setParityDotWhite(cellHV): creates a white parity dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setParityDotBlack(cellHV): creates a black parity dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setParityDotWhiteArray(list): creates multiple white parity dots
  list: list of cellHV specifications, see setParityDotWhite

setParityDotBlackArray(list): creates multiple black parity dots
  list: list of cellHV specifications, see setParityDotBlack
  
setParityDotArray(list): creates multiple parity dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setParityDotWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
Parity Lines
------------
setParityLine(list): creates a parity line constraint (parity must alternate along the line)
  list: a list of cell specifications
  
Pencilmarks
-----------
setPencilmarks(row,col,values): set pencilmarks (possible values) for a single cell
	row,col: position of cell
	values: list of possible values for the cell
	Note: instead of three positional arguments, one can use a shorthand without punctuation, e.g. 12378 assigns pencilmarks 3/7/8 to cell 1,2.
	
setPencilmarksArray(list): set multiple pencilmark constraints
	list: a list of shorthand pencilmark specifications, e.g. [12123,15289]

Position Sums
-------------
setPositionSum(row,col,rc,value1,values2): set a position sum, namely giving the sum (value1) of the first two cells adjacent to the clue (determined by row,col) and the sum of the two cells indexed by the first two cells in the column.
  row,col: The coordinates of the cell containing the cell next to which the clue values sit
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value1: The sum of the first two cells from the clue direction
  value2: The sume of the cells indexed by the first two cells from the clue direction (see Indexing)

Quadruple
---------
setQuadruple(cellVals): create a quadruple constraint on a 2x2 region
  cellVals: an extended cell specification which adds a list of values appearing in the quad to the cell specification. Shorthand is possible, e.g. 67235 will indicate the quad at 6,7 contains values 2, 3, and 5.
  
setQuadrupleArray(list): set multiple quadruples
  list: list of cellVal specifications; see setQuadruple
  
Quad Max Arrows
---------------
setQuadMaxArrow(cellDir): constraint on a 2x2 points to the unique maximum value in the quad
  cellDir: an extended cell specification which has the coordinates of the 2x2, followed by a direction specification which uses a pair of 01 values to indicate Top/Bottom,Left/Right, in order. The class variables Top, Bottom, Left and Right can be used. So for example, 1401 and (1,4,p.Top,p.Right) both indicate that the cell 15 should be larger than all of 14, 24 and 25.
  
setQuadMaxArrowArray(list): set multiple Quad Max arrow constraints
  list: list of extended cell specifications per setQuadMaxArrow method
  
Quad Max Values
---------------
setQuadMaxValue(cellValue): constraint on a 2x2 indicating the maximum value in the quad
  cellValue: an extended cell specification which has the coordinates of the 2x2, followed by the maximum value in the quad
  
setQuadMaxValueArray(list): set multiple Quad Max value constraints
  list: list of extended cell specifications per setQuadMaxValue method

Quad Sums
---------
setQuadSum(cell): assert that one of the digits in a quad is the sum of the other 3
  cell: single cell specification
  
setQuadSumArray(list): set multiple quad sum constraints
  list: list of cell specifications
  
Region Sum Lines
----------------
See Irregular Sudoku's setRegion method to set regions that affect Region Sum Lines. By default regions are the boxes in normal Sudoku rules.
setRegionSumLine(list): asserts that the sum of all cells on the line in each region is fixed across regions, regardless of contiguity along the line
  list: list of cell specifications
  
setRegionSegmentSumLine(list): asserts that the sum of cells on line in each visit to a region is fixed, with discontiguous segments in a region counted as different visits
  list: list of cell specifications
  
Renban Lines
------------
setRenbanLine(list): set a Renban line constraint
  list: list of cell specifications
  
setRunOnRenbanLine(list,n): set a run-on Renban line, i.e. a line where each contiguous subsegment of length n is a Renban line
  list: list of cell specifications
  n: length of subsegment that is a Renban. If not present, defaults to 5

Rossini Clues
-------------
Rossini clues appear as arrows on the outside of of the grid, and indicate that the first few cells next to the clue increase in the given direction. In normal Sudoku there is no ambiguity, since the number of cells used is 3, but is that 3 because of the region, or because 3 is a nice number? We provide the option to define the length of the run applied either by using regions, or specifying a value.

setRossini(row,col,rc,uldr): sets a Rossini constraint on a row or column
  row,col: The coordinates of the cell next to which the clue values sit
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  uldr: Determines if the arrow points Top/Bottom (for columns) or Left/Right (for rows)...use class variables Top, Bottom, Left, and Right
  By default, Rossini conditions operate on regions
  
setRossiniLength(value): changes cluing behavior to work on a fixed number of cells from the border
	value: number of cells to test for increase/decrease
	
setRossiniNegative(): assert a negative constraint on the Rossini conditions, i.e. rows/columns without clues do not strictly increase/decrease in the Rossini window

Samurai Sudoku
--------------
To model a Samurai Sudoku puzzle, you must use the class samuraiSudoku, e.g.

p = ORsudoku.samuraiSudoku(boardSizeRoot)

The 5 sub-Sudoku puzzles are labelled
1 2
 3
4 5

In this class, you can use the following method:
setSamuraiConstraint(puzzle,constraint,argsd): sets a Samurai constraint
	puzzle: the puzzle number (1-5) to which the constraint should apply
	constraint: a string containing the name of the constraint (e.g. 'GivenArray')..do not include the 'set' used in the method name
	args: the arguments that you wish to pass to the constraint, just as if you were passing them with the normal 'set' method

Sandwich Sums
-------------
setSandwichSum(row,col,rc,value,digits): sets a sandwich sum constraint
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the values between the 1 and 9 in the clued row/column
  digits (optional): A list of two digits to form the "bread" of the sandwich. Defaults to the minimum and maximum digit.
  
Shift Lines
-----------
setShiftLine(inlist): sets a shift line constraint; like a plaindrome, but one side is uniformly one larger than the other
  inlist: list of cell specifications

Skyscrapers
-----------
setSkyscraper(row,col,rc,value): sets a skyscraper constraint, specifying the number of digits that can be "seen" from the clue, where seen means greater than all digits between it and the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the number of digits that can be seen
  
Unicorn Digits
--------------
setUnicornDigit(value): set a unicorn digit, i.e. for any instance of that digit in the grid, all of the cells a knight's move away have distinct values
	value: value of the digit to be a unicorn

Up and Down Lines
-----------------
setUpAndDownLine(inlist): sets an up and down line constraint; cells must laternately increase and decrease
  inlist: list of cell specifications
  
Thermometers
------------
setThermo(list): asserts that the values in cells increase from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  
setSlowThermo(list): asserts that the values in cells do not decrease from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  
Weak Palindrome Lines
---------------------
setWeakPalindromeLine(list): creates a weak palindrome line constraint: instead of matching digits, palindromic positions must match on parity and magnitude (1-4 vs. 5-9)
  list: a list of cell specifications
  
Whispers Lines
--------------
setMinWhispersLine(inlist,value): asserts two adjacent cells on a line have a difference of at least value
	inlist: list of cell specifications
	value: integer

setMaxWhispersLine(inlist,value): asserts two adjacent cells on a line have a difference of at most value
	inlist: list of cell specifications
	value: integer
	
setChineseWhispersLine(inlist): two adjacent cells on a line have a difference of at most 2
	inlist: list of cell specifications
	
setDutchWhispersLine(inlist): two adjacent cells on a line have a difference of at least 4
	inlist: list of cell specifications
	
setGermanWhispersLine(inlist): two adjacent cells on a line have a difference of at least 5
	inlist: list of cell specifications

Windoku
-------
setWindoku(): assert Windoku rules

X-Kropki
--------
setXKropki(row,col,rc,wb,neg): The first cell next to the Kropki dot (outside the grid) indicates the position (0-7) of the corresponding Kropki dot in the row/column. Designed by Zegres.
  row,col: coordinates of the cell next to the clue
  rc: indicates whether rule applies to row or column. Use Row and Col class variables
  wb: indicates whether Kropki clue is white or black. Use White and Black class variables
  neg (optional, default False): If true, indicates that there are no other Kropki relationships of the same color in the row/column
  
XSudoku
-------
setXSudokuMain(): assert no repeats on the main (top left to bottom right) diagonal

setXSudokuOff(): assert no repeats on the off (top right to bottom left) diagonal

X-Sum
-----
setXSum(row,col,rc,value): set an X sum constraint on a row or column
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells in the row/column from the clue, where X is the value in the adjacent cell
  
XV/XV Pairs
-----------
setXVV(cellHV): creates a V clue
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a V clue on the bottom edge of cell 2,5
  
setXVX(cellHV): creates an X clue
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify an X clue on the bottom edge of cell 2,5
  
setXVVArray(list): creates multiple V clues
  list: list of cellHV specifications, see setXVV

setXVXArray(list): creates multiple X clues
  list: list of cellHV specifications, see setXVX
  
setXVArray(list): creates multiple X/V clues
  list: list of cellHVXV specifications, which include a cell spec, the HV spec as given in setXVV, and a XV spec, specifying the type of clue. When given as a tuple, the X and V variables can be used to specify X/V clues. Shorthand is possible, with V being 0 and X 1.
  Example: 1701 incidates an X (1 XV spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.X)
  
setAntiXV(cellHV): asserts that a pair of cells cannot add to either 5 or 10
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXVArray(list): creates multiple anti-XV clues
  list: list of cellHV specifications, see setXVV

setXVNegative(): implements negative constraint

XVXV
----
setXVXVV(cellHV): creates a V clue, in XVXV rules, where sum may be 5 or 15
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a V clue on the bottom edge of cell 2,5
  
setXVXVX(cellHV): creates an X clue, in XVXV rules, where sum may be 10 or 15
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify an X clue on the bottom edge of cell 2,5
  
setXVXVVArray(list): creates multiple V clues
  list: list of cellHV specifications, see setXVV

setXVXVXArray(list): creates multiple X clues
  list: list of cellHV specifications, see setXVX
  
setXVXVArray(list): creates multiple X/V clues
  list: list of cellHVXV specifications, which include a cell spec, the HV spec as given in setXVV, and a XV spec, specifying the type of clue. When given as a tuple, the X and V variables can be used to specify X/V clues. Shorthand is possible, with V being 0 and X 1.
  Example: 1701 incidates an X (1 XV spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.X)
  
setAntiXVXV(cellHV): asserts that a pair of cells cannot add to either 5 or 10 or 15
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXVXVArray(list): creates multiple anti-XVXV clues
  list: list of cellHV specifications, see setXVXVV
  
setXVXVNegative(): implements negative constraint

Zones
-----
setZone(list,values): sets a zone, i.e., a set of cells and a list of values such that each value must appear in the zone, *including repeats*
  list: list of cell specifications
  values: list of values to appear in the zone
  
Note that this method can be used to implement look-and-say cages as well, just by interpreting the clue string as a list of values, e.g. 27 becomes [7,7]