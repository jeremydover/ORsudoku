Supported Constraint List
=========================
10 Lines
159 (see Indexing)
All Odd or Even
Alternate Digits
Anti-Diagonal - see XSudoku
Anti-King
Anti-Knight
Anti-Queen
Arrows
Ascending Starters
Average Lines
Battenburg
Battlefield
Before Nine - see Sandwich Sums
Bent Diagonals - see XSudoku
Between Lines
Block Cages
Broken Thermos - see Thermometers
Broken X-Sums - see X-Sum
Bust
Capsules
Cell Index Lines
Cell Transform Sudoku
Chinese Whispers Lines - see Whispers Lines
Clock Lines
Clone Regions
Close Neighbors - see Global Whispers
Conditional Count Cross - see Conditional Lines
Conditional Count Lines - see Conditional Lines
Conditional Count Segment - see Conditional Lines
Conditional Instance Lines - see Conditional Lines
Conditional Sandwich Sums - see Sandwich Sums
Conditional Sum Lines - see Conditional Lines
Conditional Sum Segment - see Conditional Lines
Consecutive Chain Regions
Consecutive Lines
Consecutive Quads
Copycat Cells - see Cell Transform Sudoku
Corner/Edge Clues
Count the Odds Lines
Counting Circles
Crust Sandwich - see Sandwich Sums
Cupid Clues
David and Goliath Pairs
Descriptive Pairs
Diagonal Consecutive Pairs
Diagonal Mirrors
Difference Pairs - see Kropki and Kropki Pairs
Different Neighbors
Digit Count Cages
Disjoint Groups
Dominant Clone Regions - see Clone Regions
Double Arrows - see Arrows
Double or Nothing Sudoku - see Cell Transform Sudoku
DoubleDoku
Doubler Sudoku - see Cell Transform Sudoku
Double Thermos - see Thermos
Double X Sums - see X Sums
Doubling Lines
Dutch Flat Mates - see Flat Mates
Dutch Whispers Lines - see Whispers Lines
Either-Or
Entropic Lines
Entropic Mirror - see Diagonal Mirrors
Entropic Whispers Lines - see Extended Whispers Lines
Entropki Dots (same/different entropy classes)
Entropy (see Global Entropy)
Entropy Battenburg (on a 2x2, no pair of same entropic cells are adjacent)
Entropy Quads (partial Entropy, asserts Entropy on an individual 2x2)
Equal Sum Cages
Equiparity/Uniparity Cages - see More-Odd-Than-Even Cages
Even Max Quads - see Quad Max Values
Even-Odd
Extended Whispers Lines
Extra Regions - see irregular Sudoku
Fast Thermos - see Thermos
First-Seen Parity/Entropy/Modular
Flat Mates
Forbidden Consecutive Sums
Fortress
Friendly Cells
Full Rank
Gamma-Epsilon - see Kropki
Generalized Knightmare (see Anti-Knight)
Genetics
German Whispers Lines - see Whispers Lines
Given Digits
Global Entropy
Global Modular (see Global Entropy)
Global Neighbor Sums
Global Whispers (Dutch, et. al.)
Gurth's Symmetric Placement (GSP)
Hanging Sums/Counts/Averages/Instances
Hidden Arrows - see Missing Multi-Digit Arrow under Arrows
Hidden Clones
In Order
Indexing
Indexed Pair Sums
Irregular Sudoku
Isotopes
Japanese Sum Sudoku
Keypad King Lines
Keypad Knight Lines
Killer Cages (repeating and non-repeating)
Knapp Daneben Cages - see Killer Cages
Knightmare (seee Anti-Knight)
Kropki (see Kropki Pairs)
Kropki Pairs
Line Sum Lines
Little Killer
Lockout Lines
Logic Bombs
Look-and-Say Cages - see Zones
Lot Lines
Magic Lines
Magic Squares
Magnitude Mirror - see Diagonal Mirrors
MaxAscending
Maximin - see Minimax
Maximum Runs (Maximum Triplets)
MaxMin Sum Cages
MaxMin Quads - see MaxMin Sum Cages
Median Cages
Min-Max
Minimax
Missing Arrow - see Arrows
Missing Bulb Thermos - see Thermometers
Modular Lines
Modular Quads - see Entropy Quads
More-Odd-Than-Even/More-Even-Than-Odd Cages
Nabner Lines
Nearest Neighbor
Negator Sudoku - see Cell Transform Sudoku
Neighbor Sets
Neighbor Sums
Next-To-Nine
No-Three-In-A-Row (Parity)
No Seven - see Forbidden Consecutive Sums
Non-Consecutive
Numbered Room
Odd-Even Thermos - see Thermometers
Odd Max Quad - see Odd Max Values
Offset Digits
Openfaced Sandwich Sums - see Sandwich Sums
Order Sum Cages
Outside Clues
Outside Diagonal Clues
Palindrome Lines
Parindrome Lines - see Palindrome Lines
Parity Count Lines (endpoints show the number of odd/even digits along the line)
Parity Dots
Parity Lines (alternating parity along line)
Parity Mirror - see Diagonal Mirrors
Parity Party
Parity Quads (2x2 regions which contain both parities)
Parity Snakes
Pencilmarks
Pool
Potpourri N-Sums
Psycho Killer Cages - see Killer Cages
Psycho Look-And-Say Cages - see Zones
Pointing Arrows - see Arrows
Pointing Differents
Position Sums
Primality Mirror - see Diagonal Mirrors
Punctured Cages - see Killer Cages
Quadruple
Quad Max Arrows
Quad Max/Min Parity - see Quad Max/Min Values
Quad Max/Min Parity Values - see Quad Max/Min Values
Quad Max/Min Values
Quad Sums (one digit on a quad is the sum of the three others)
Quadro (no 2x2 in grid has all even or all odd digits) - see Parity Quads
QuattroQuadri
Ranked Cages - see Killer Cages
Ray Counts and Sums - see Hanging Sums
Ratio Pairs - see Kropki and Kropki pairs
Region Sum Lines (sum of all cells along a line in a region is fixed)
Region Segment Sum Lines - see Region Sum Lines
Remote Clone Cell
Remote Kropki Arrows - see Kropki
Removed Bulb Thermos - see Thermos
Renban Lines
Renrenbanban Lines (see Renban Lines)
Repeated Neighbors
Repeating Arrows - see Arrows
Repelling Digits
Reverse Numbered Rooms - see Numbered Rooms
Reverse X-Sums - see X-Sum
Roman Sums - see XV/XV Pairs
Roping
Rossini Clues
Rotational Pairs - see Gurth's Symmetric Placement
Row/Column Region Sum
Run-On Renban Lines - see Renban Lines
Run-On Nabner Lines - see Extended Whispers Lines
Samurai Sudoku
Sandwich Sums
Scary Cells
Schr√∂dinger Cell Sudoku
Search Nine
Sequence Lines
Shaken Clone Regions - see Clone Regions
Shift Lines
Skyscrapers
Skyscraper Sums - see Skyscrapers
Slingshots
Slot Machine
Slow Thermometers (see Thermometers)
Split Pea Lines
Split Pill Lines - see Split Pea Lines
Star Battle Sudoku
Sum Dots (see Killer Cages)
Sum Sandwiches
Sweepers
Thermometers
Triple Tabs
Unicorn Digits
Uniparity/Equiparity Cages - see More-Odd-Than-Even Cages
Unique Pairs Lines
Vaults
Weak Palindrome Lines
Windoku
X-Average - see X-Sum
X-Distance
X-Kropki
X-Outside
XSudoku
X-Sum
XV (see XV Pairs)
XV Pairs
XVXV
XY-Difference Pairs
Zipper Lines
Zones

Some Notes on Data Structures
-----------------------------
All cells are indexed as tuples, e.g. (4,6), per the following array:

----------------------------
|11|12|13|14|15|16|17|18|19|
----------------------------
|21|22|23|24|25|26|27|28|29|
----------------------------
|31|32|33|34|35|36|37|38|39|
----------------------------
|41|42|43|44|45|46|47|48|49|
----------------------------
|51|52|53|54|55|56|57|58|59|
----------------------------
|61|62|63|64|65|66|67|68|69|
----------------------------
|71|72|73|74|75|76|77|78|79|
----------------------------
|81|82|83|84|85|86|87|88|89|
----------------------------
|91|92|93|94|95|96|97|98|99|
----------------------------

When a constraint requires a cell or list of cells, they can be input in one of three ways:
1. Explicitly as a tuple, e.g., (5,6)
2. As a string, e.g., '85'
3. As an integer, e.g., 16.

Note: The non-tuple cell inputs WILL break on boards larger than 9x9. However, since 9x9 is by far the most popular use case, these shortcuts are worth having.

Quadruples are indexed similarly, from 11 to 88:

-------------------------------------
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---1,1-1,2-1,3-1,4-1,5-1,6-1,7-1,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---2,1-2,2-2,3-2,4-2,5-2,6-2,7-2,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---3,1-3,2-3,3-3,4-3,5-3,6-3,7-3,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---4,1-4,2-4,3-4,4-4,5-4,6-4,7-4,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---5,1-5,2-5,3-5,4-5,5-5,6-5,7-5,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---6,1-6,2-6,3-6,4-6,5-6,6-6,7-6,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---7,1-7,2-7,3-7,4-7,5-7,6-7,7-7,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---8,1-8,2-8,3-8,4-8,5-8,6-8,7-8,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
-------------------------------------

Edge constraints are indexed by the top- or left-most cell in the pair of adjacent cells. An additional parameter hv is provided to determine whether the pair is horizontal or vertical. The class variables Horz and Vert can be used for this designation. 

Notes on primes: By default, 1 is considered neither prime, nor not prime. This behavior can be configured with the method:
configurePrimality(whatIsOne): set behavior of 1 in primality constraints. Options are 'Prime', 'NotPrime' or 'Neither'

10 Lines
--------
set10Line(inlist,value): asserts a line that can be partitioned into non-overlapping segments, each of whose cells sum to the given value
  inlist: list of cell specifications
  value: Optional, default is 10. Value to which chunks on the line need to sum to
Note: If the 10 line closes back on itself, ensure that the first and last cell in the list are the same. The code is aware of this case and will not add the endpoint a second time.

All Odd or Even
---------------
setAllOddOrEven(list): given a list of "shaded" cells defined by list, all shaded cells in each region have the same parity
  list: list of cell specifications

Alternate Digits
----------------
If a puzzle does not have a 1-9 digit set (0-8 being the most common alternative), then an alternate digit set can be added by including the digitSet parameter when instantiating the puzzle, e.g.,
p = ORsudoku.sudoku(boardSizeRoot,digitSet={0,1,2,3,4,5,6,7,8})

Anti-King
---------
setAntiKing(): applies the anti-king constraint to the whole puzzle

Anti-Knight
-----------
setAntiKnight(): applies the anti-knight constraint to the whole puzzle

setKnightMare(): applies the Knightmare constraint, where no two cells a knight's move apoart can sum to either 5 or 15.

setGeneralizedKnightMare(list): applies the Knightmare constraint with a specified list of forbidden sums at a knight's move apart. Defaults to standard knightmare.

Anti-Queen
----------
A strictly anti-queen sudoku does not exist, but there are several more limited constraints which do not allow certain repeats on diagonals

setAntiQueenDigit(values): asserts that no instances of a digit in the list values can repeat on any diagonal
	values: a single digit, or a list of digits
	
setAntiQueenCell(cell[cell2]): asserts that digit in this cell does not repeat on diagonals, or does not repeat on some diagonal
  cell: typical cell specification
  cell2: optional cell specification: if omitted, digit in first cell does not repeat on any diagonal. If present, cell does not repeat on diagonal in direction of r2,c2...most common usage is to have r2,c2 diagonally adjacent to original cell
  Can use shorthand, e.g. 5566 to indicate no repeats from 55 down the main diagonal
  
Arrows
------
setArrow(inlist): creates an arrow constraint
  inlist: a list of cells along arrow, where the first element of list is the circle
  
setDoubleArrow(inlist): creates a double arrow constraint - sum of cells between the endpoint equals the sum of the endpoints
  inlist: a list of cells along arrow, where the first element of list is the circle
  
setHeavyArrow(inlist,mult): creates a heavy arrow, where the sum of the cells along the arrow is a multiple of the first cell
  inlist: a list of cells along arrow, where the first element of list is the circle
  mult: Optional, default is 2. The factor by which the first cell is multiplied. By default, the cells on the arrow add up to twice the value in the bulb
  
setPointingArrow(list): creates a pointing arrow, which is both a regular arrow, and whose other end points (as determined by the last two cells) at another copy of the sum
  list: a list of cells along arrow, where the first element of list is the circle
  
setMultiDigitSumArrow(list,n): creates an arrow where the sum is multi-digit, interpreted base 10
  list: a list of cells along the arrow where the first n elements are in the circle, listed from most-significant to least significant
  n: the number of digits in the circle
  
setMissingArrow(list): an arrow where either end cell of the arrow may be the sum of the rest of the elements on the arrow
  list: a list of cells along arrow, where either the first or last element of list is the sum of the rest
  
setRepeatingArrow(list,repeat): an arrow where the arrow portion can be paritioned into contiguous cells whose sum is the value in the bulb
  list: a list of cells along arrow, where the first element of list is the circle
  repeat (optional): the number of times the circle sum will repeat, default is 2
  
setMultiDigitSumMissingArrow(list): (also known as hidden arrows) a missing arrow (so either end can be the circle) where the circle can contain multiple digits, interpreted base 10
  list: a list of cells along arrow
  
Ascending Starters
------------------
setAscendingStarter(row,col,rc,value): specifies the sum of the ascending run (which may be only one digit) starting at the cell next to the clue
  row,col: The coordinates of a cell on either end of the row/column
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the sum of the ascending run of digits next to the clue
  
Average Lines
-------------
setAverageLine(inlist): creates an average line, where the first cell in the list is the average (arithmetical mean) of the cell values in the list
  inlist: a list of cells specifications
  
Battenburg
----------
setBattenburg(cell): creates a Battenburg constraint (no cells on the quad with the same parity share an edge)
  cell: a single cell specification, e.g., 13,'25',(4,7)
  
setBattenburgArray(list): creates multiple Battenburg constraints
  list: a list of cell specifications
  
setAntiBattenburg(cell): creates a negative Battenburg constraint (the Battenburg condition does NOT hold)
  cell: a single cell specification, e.g., 13,'25',(4,7)
  
setAntiBattenburgArray(list): creates multiple negative Battenburg constraints
  list: a list of cell specifications

setBattenburgNegative(): specify that all cells not specifically designated with Battenburgs do NOT satisfy the Battenburg constraint

Battlefield
-----------
setBattlefield(row,col,rc,value): implements a Battlefield constraint in a row or column
  row,col: The coordinates of a cell on either end of the row/column
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: summarized from Realshaggy: Consider the first x and last y cells of a row or column where x is the value of the first and y the value of the last cell. value is the sum of the digits where these groups overlap or the sum of the digits between these groups.
  
Between Lines
-------------
setBetweenLine(list): creates a between line constraint
  list: a list of cell specifications
  
Block Cages
-----------
setBlockCage(list,values): creates a block cage, that is an list of cells and a list of values, such that those values cannot appear within the cage
  list: list of cell specifications
  values: a list of values...if unambiguous the punctuation can be omitted, so that [1,2,3,9] and 1239 can both be entered as a value list

Bust
----
setBust(row,col,rc,value,targetSum=21): creates a bust constraint, which is the number of cells it takes, reading from the clue, for the total sum to exceed the targetSum value (default 21)
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: number of cells from clue whose sum first exceeds the given sum
  targetSum: the target value to exceed, default 21

Capsules
--------
setCapsule(inlist): creates a capsule, i.e., a region with the same number of even and odd digits. See also More-Odd-Than-Even cages
  list: list of cell specifications

Cell Index Lines
----------------
setCellIndexLines(inlist): creates a set of lines, each of length three, where each line indexes (see Indexing) a cell in the grid. From one end of the line, which can be either end, the line reads row/column/value. Moreover, the cells thus indexed are all in different rows, different columns, and contain different digits.
  inlist: list OF LISTS of cell specifications, each list is a line

Cell Transform Sudoku
---------------------
Inspired by the doubler rules invented by zetamath. Grid is as normal, but one cell in each row, column and region is transformed when used in other constraints. To model cell transform contraints requires use of a different class:

from cellTransformSudoku import cellTransformSudoku
p = cellTransformSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  All three parameters are optional:
  canRepeatDigits: if canRepeatDigits is True, then the constraint that the base digits of all transformed cells need to be distinct is waived. Default is False
  irregular and digitSet are settable just like the regular Sudoku class

By default the cellTransformSudoku class just implements Doubler Sudoku. Doubler Sudoku can also be initialized with:
from cellTransformSudoku import doublerSudoku
p = doublerSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)

To implement other rulesets, one needs additional classes:

from cellTransformSudoku import negatorSudoku
negatorSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  Just like doubler Sudoku, but the designated cells are negated, not doubled
  
from cellTransformSudoku import doubleOrNothingSudoku
doubleOrNothingSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  The designated cells are either doubled, or count as zero, in other constraints. Note: this behavior is consistent; each cell is either doubled or nothing, and does not vary depending on which constraint is applied.
  
from cellTransformSudoku import affineTransformSudoku
affineTransformSudoku(boardSizeRoot,ratio,shift,canRepeatDigits,irregular,digitSet)
  The parameters ratio and shift are required, and the transformed digits count as ratio*value+shift to all constraints.
  Doubler Sudoku is the same as affineTransformSudoku(3,2,0)
  Negator Sudoku is the same as affineTransformSudoku(3,-1,0)
  
from cellTransformSudoku import copycatSudoku
copycatSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  Transformed cells take on the value the digit placed in the grid at 180 degree rotation

Special methods for Cell Transform Sudoku
setTransform(cell): asserts that a particular cell is a transform cell
  cell: cell specification
  
setNotTransform(cell): asserts that a particular cell is not a transform cell
  cell: cell specification
  
setTransformAntiKing(): asserts that two transform cells may not be within a king's move of each other, i.e. not diagonally adjacent

Clock Lines
-----------
setClockLine(list): ceates a clock line, where adjacent cells on the line differ by either 2 or 7
  list: list of cell specifications

Clone Regions
-------------
setCloneRegion(list): creates a set of regions that are clones of each other, i.e., the same digit appears in the ith position for each i
  list: a list OF LISTS of cell specifications
  
setDominantCloneRegion(list,strict): creates a set of regions such that in every position, the first region has a digit larger than the corresonding digit in all other regions
  list: a list OF LISTS of cell specifications
  strict: OPTIONAL, defaults to True. If strict, dominant clone contains strictly greater than digits. If strict is False, this is relaxed to greater than or equal to.
  
setShakenCloneRegion(list,noRepeat): creates a set of regions that contain the same multi-set of digits
  list: a list OF LISTS of cell specifications
  noRepeat: OPTIONAL, defaults to False. If noRepeat, digits cannot repeat in the zone. By default, repeats are allowed.
  
Conditional Lines
---------------------
setConditionalCountLine(list,value,selectCriteria,terminationCriteria,terminateOn,includeTerminator,comparator,forceTermination): analogous to a Hanging Count, but along a line instead of just in a column
  list: list of cell specifications
  See Hanging Sums for a description of all other parameters

setConditionalSumLine(list,value,selectCriteria,terminationCriteria,terminateOn,includeTerminator,comparator,forceTermination): analogous to a Hanging Sum, but along a line instead of just in a column
  list: list of cell specifications
  See Hanging Sums for a description of all other parameters
  
setConditionalInstanceLine(list,values,selectCriteria,terminationCriteria,terminateOn,includeTerminator,negativeConstraint,forceTermination): analogous to a Hanging Instance, but along a line instead of just in a column
  list: list of cell specifications
  See Hanging Sums for a description of all other parameters
  
setConditionalCountCross(row,col,value,selectCriteria,terminationCriteria,terminateOn,includeTerminator,comparator,forceTermination,includeSelf): given a cell in the grid, counts all of the desired instances in all of the orthogonal rays emanating from the cell.
  row,col: cell specification
  value: can be an integer, or the string 'self' - in this latter case, the count matches the value in the cell
  See Hanging Sums for a description of selectCriteria, terminationCriteria, terminateOn, includeTerminator, comparator, forceTermination
  includeSelf: By default, the cell from which the rays are emanating is counted once if it meets the criteria. Setting this to false will not include the base cell.

setConditionalCountSegment(list,value,selectInitiator,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,comparator=None,forceTermination=True,includeSelf=True,backward=True,forward=True): given a line in the grid, an initiating cell is chosen according to the selectInitiator criteria, and cells are counted one or both ways from the initiating cell to the ends of the line. All parameters are as described in setRayCount

setConditionalSumSegment(list,value,selectInitiator,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,comparator=None,forceTermination=True,includeSelf=True,backward=True,forward=True): given a line in the grid, an initiating cell is chosen according to the selectInitiator criteria, and cells are summed one or both ways from the initiating cell to the ends of the line. All parameters are as described in setRaySum

Consecutive Chain Regions
-------------------------
setConsecutiveChainRegion(list): creates a region which has contains a set of consecutive digits such that an orthogonal snake can be drawn within the region from the lowest to the highest digit
	list: list of cell specifications
NOTE: do NOT use this constraint with countSolutions...the chain construction creates numerous free Booleans which can flap while leaving the numerical solution fixed

Consecutive Lines
-----------------
setConsecutiveLine(list): creates a line which consists of consecutive digits in order from lowest to highest (which end is lowest is not specified)
	list: a list of cell specifications
  
Consecutive Quads
-----------------
On a quad, a black dot indicates at least two pairs of cells in the quad, including diagonals, have consecutive digits, while a white indicates exactly one pair.

setConsecutiveQuadWhite(cell):	set a single white consecutive quad dot
	cell: single cell specification
	
setConsecutiveQuadWhiteArray(list): set multiple white consecutive quad dots
	list: a list of cell specifications
	
setConsecutiveQuadBlack(cell):	set a single black consecutive quad dot
	cell: single cell specification
	
setConsecutiveQuadBlackArray(list): set multiple black consecutive quad dots
	list: a list of cell specifications
	
setConsecutiveQuadArray(list): set multiple black/white consecutive quad dots
	list: a list of extended cell specifications, containing row/col, plus an indication of whether the dot is white (0) or black (1). Use the Black and White class variables for surety.
	
setAntiConsecutiveQuad(cell): asserts that there are no consecutive pairs of digits amongst the 6 pairs of digits in the quad
	cell: cell specification
	
setAntiConsecutiveQuadArray(list): assert multiple anti-consecutive quad conditions
	list: a list of cell specifications
	
setConsecutiveQuadNegative(): assert that all possible dots are given, so places without dots have no consecutive pairs

Corner/Edge Clues
-----------------
setCornerEdge(box,ce,valueList): sets a list of values that must appear in a corner or on an edge of a BOX (not region)
  box: integer denoting box, upper left corner is 1, to its right is 2, etc.
  ce: determines whether clue is for corners or edges. 0 or class variable Corner for corner, 1 or class variable Edge for edge
  valueList: list of cell values for which to assert placement

Count the Odds Lines
--------------------
setCountTheOddsLine(list): set a count the odds line, where the digit in the first cell of the line counts the number of odd digits on the rest of the line; pioneered by clover!
  list: list of cell specifications
  
Counting Circles
----------------
setCountingCircles(list): given a list of circled cells, a digit in a circled cell is the number of times that digit appears in a circled cell
  list: list of circle cells

Cupid Clues
-----------
setLittleCupid(row1,col1,row2,col2): sets a cupid clue: value in the cell (row1,col1) must also appear along the diagonal in the direction of (row2,col2)
  row1,col1: the cell spec of the cupid cell
  row2,col2: the cell spec for the next cell in the diagonal along which the cupid arrow points

David and Goliath Pairs
-----------------------
setDavidAndGoliath(list,borderDigit,borderType): sets a David and Goliath pair, where at least one cell must have a "David" (small) digit and at least one must have a "Goliath" (large) digit
  list: list of two cell specifications
  borderDigit: (Optional) digit that defines the border between small and large, defaults to 5
  borderType: (Optional) if -1, border digit is David and not Goliath; if 1, border digit is Goliath and not David; if 0, border digit is both David and Goliath (default is 0)

Descriptive Pairs
-----------------
setDescriptivePair(row,col,rc,values): clue on a row or column with two digits XY; either X is in Yth position, or Y is in Xth
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: A list or tuple of digits defining the pair. A 2-digit integer (e.g. 45) can also be given. Negative digits are allowed, and index from the opposite end of the row/column

Diagonal Consecutive Pairs
--------------------------
setDiagonalConsecutivePairs(cell):	asserts that the diagonal pairs on this 2x2 are consecutive digits
	cell: single cell specification
	
setDiagonalConsecutivePairsArray(list): set multiple diagonal consecutive pairs
	list: a list of cell specifications

Diagonal Mirrors
----------------
Diagonal mirrors allow the main and/or off diagonals to serve as mirrors, or anti-mirrors, for certain numeric properties. Currently supported properties are:
Entropy - low, middle, high
Magnitude - {1,2,3,4,5}, {5,6,7,8,9} (note: 5 is a wildcard and matches either set)
Parity
Primality - {1,2,3,5,7}, {1,4,6,8,9} (note: 1 is a wildcard and matches either set)

A mirror ensures that cells reflected across a diagonal have the same value for the property, an anti-mirror ensures those properties are different. Supported functions include:
setEntropyMirrorMain()
setEntropyMirrorOff()
setEntropyAntiMirrorMain()
setEntropyAntiMirrorOff()
setMagnitudeMirrorMain()
setMagnitudeMirrorOff()
setMagnitudeAntiMirrorMain()
setMagnitudeAntiMirrorOff()
setParityMirrorMain()
setParityMirrorOff()
setPrimalityMirrorOff()
setPrimalityAntiMirrorMain()
setPrimalityAntiMirrorOff()

Note that parity anti-mirror does not lead to any solutions, so it is not supported.

Different Neighbors
-------------------
setDifferentNeighbors(row,col,includeCell): asserts that the number of distinct digits in the neighborhood of (row,col) (including diagonals) is equal to the digit in the cell. Can optionally include the cell itself in the digit count
  row,col: cell specification
  includeCell: default False: if set includes the cell itself in the count of digits, default is to only count the 8 adjacent cells

Digit Count Cages
-----------------
setDigitCountCage(inlist,value): asserts that value is the number of distinct digits appearing in the cage; pioneered by clover!
  inlist: list of cell specifications
  value: integer counting number of distinct digits

Disjoint Groups
---------------
setDisjointGroups(): sets the global disjoint groups constraint

DoubleDoku
----------
To model a DoubleDoku puzzle, you must use the class doubleDoku, e.g.

from multiSudoku import doubleDoku
p = doubleDoku(boardSizeRoot)

The sub-Sudoku puzzles are labelled:
1
 2
 
The puzzles overlap with one box of fringe, so a 9x9 shares 4 boxes, and 16x16 shares 9 boxes, etc.

In this class, you can use the following method:
setDoubleDokuConstraint(puzzle,constraint,argsd): sets a DoubleDoku constraint
	puzzle: the puzzle number (1-2) to which the constraint should apply
	constraint: a string containing the name of the constraint (e.g. 'GivenArray')..do not include the 'set' used in the method name
	args: the arguments that you wish to pass to the constraint, just as if you were passing them with the normal 'set' method

Doubling Lines
--------------
setDoublingLine(list): creates a doubling line constraint: every digit appears exactly twice on the line
  list: a list of cell specifications

Either-Or
---------
setEitherOr(cellHVV): Given an extended cell specification with a row, column, a Horz/Vert, and a value, assert the given value appears in one of the two cells defined by the cellHV specification
  cellHVV: an extended cell specification which adds the hv parameter: circle is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical. A value is also given, defining the value to appear in either cell
  Example: 2518, '2518' and (2,5,p.Vert,8) all specify a circle on the bottom edge of cell 2,5, asserting either cell 25 or cell 35 is an 8
  
setEitherOrArray(list): assert multiple Either-Or constraints
  list: list of extended cell specifications, see setEitherOr

Entropic Lines
--------------
setEntropicLine(list): creates an entropic line constraint
  list: a list of cell specifications
  
Entropki Dots
-------------
Entropki dots are placed like Kropki dots, but white dots indicate the adjacent cells are of different entropic ranks, while black dots indicate the adjacent cells are of the same entropic rank.

setEntropkiWhite(cellHV): creates a white Entropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setEntropkiBlack(cellHV): creates a black Entropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setEntropkiWhiteArray(list): creates multiple white Entropki dots
  list: list of cellHV specifications, see setEntropkiWhite

setEntropkiBlackArray(list): creates multiple black Entropki dots
  list: list of cellHV specifications, see setEntropkiBlack
  
setEntropkiArray(list): creates multiple Entropki dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setEntropkiWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
Entropy Battenburg
------------------
setEntropyBattenburg(cell): creates an entropy Battenburg constraint (no cells on the quad of the same entropic rank share an edge)
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setEntropyBattenburgArray(list): creates multiple entropy Battenburg constraints
  list: a list of cell specifications
  
setAntiEntropyBattenburg(cell): creates an anti-entropy Battenburg constraint (some pair of adjacent cells on the quad have the same entropic rank)
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiEntropyBattenburgArray(list): creates multiple anti-entropy Battenburg constraints
  list: a list of cell specifications
  
setEntropyBattenburgNegative(): specify that all cells not specifically designated with entropy Battenburgs do NOT satisfy the entropy Battenburg constraint

Entropy Quads
-------------
setEntropyQuad(cell): creates an entropy constraint (all three entropic ranks must appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setEntropyQuadArray(list): creates multiple entropy quad constraints
  list: a list of cell specifications
  
setAntiEntropyQuad(cell): creates an anti-entropy constraint (all three entropic ranks cannot appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiEntropyQuadArray(list): creates multiple anti-entropy quad constraints
  list: a list of cell specifications
  
setEntropyQuadNegative(): specify that all cells not specifically designated with entropy quads do NOT satisfy the entropy quad constraint, i.e., some entropic rank will be missing around each quad which is not an entropy quad

The following analogous functions are available for modular quads, which are the same as Entropy quads, but use the modular grouping {1,4,7},{2,5,8},{3,6,9}

setModularQuad(cell): creates an entropy constraint (all three entropic ranks must appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setModularQuadArray(list): creates multiple entropy quad constraints
  list: a list of cell specifications
  
setAntiModularQuad(cell): creates an anti-entropy constraint (all three entropic ranks cannot appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiModularQuadArray(list): creates multiple anti-entropy quad constraints
  list: a list of cell specifications
  
setModularQuadNegative(): specify that all cells not specifically designated with entropy quads do NOT satisfy the entropy quad constraint, i.e., some entropic rank will be missing around each quad which is not an entropy quad

Equal Sum Cages
---------------
setEqualSumCages(inlist): asserts that the sum of the digits in each specified cage is the same
  inlist: a list OF LISTS of cell specifications

Even-Odd
--------
setEven(cell): asserts the cell value is even
  cell: single cell specification

setOdd(cell): asserts the cell value is odd
  cell: single cell specification
  
setEvenOdd(cellEO): asserts the parity of a cell
setOddEven(cellEO): asserts the parity of a cell
  cellEO: a cell specification augmented with an even odd specification. Tuple specification may use the Even and Odd variables, e.g. (5,8,p.Odd). Shorthand is possible, using 0 for even and 1 for odd. Thus 581 is an alternative specification for the same assertion.
  
setEvenArray(list): create multiple even constraints
  list: list of cell specifications
  
setOddArray(list): create multiple odd constraints
  list: list of cell specifications
  
setEvenOddArray(list): create multipl parity constraints
setOddEvenArray(list): create multipl parity constraints
  list: list of cellEO specifications; see setEvenOdd
  
Extended Whispers Lines
-----------------------
setMinExtendedWhispersLine(list,difference,reach): set contraint that cells at most reach cells apart on the line given by list differ by at least difference
	list: list of cell specifications
	difference: minimum difference between "close" cells
	reach: number of adjacent cells on line defining "close"
	
setMaxExtendedWhispersLine(list,difference,reach): set contraint that cells at most reach cells apart on the line given by list differ by at most difference
	list: list of cell specifications
	difference: maximum difference between "close" cells
	reach: number of adjacent cells on line defining "close"

setEntropicWhispersLine(list): line where cells at most two cells apart along the line differ by at least 3
	list: list of cell specifications
	
setRunOnNabnerLine(list): line where cells at most three cells apart along the line differ by at least 2; this is equivalent to the definition of a run-on nabner line analogous to a run-on renban line, as it assures that no two cells along any stretch of 5 in a line are consecutive
	list: list of cell specifications

First-Seen Clues
----------------
First-seen clues indicate the first value with a given property seen from outside the grid

setFirstSeenParity(row,col,rc,value): asserts the first digit with the parity of value seen in the row/column is the given value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: first even/odd value seen in the row/column
  
setFirstSeenEntropy(row,col,rc,value): asserts the first digit in the entropic stratum of value seen in the row/column is the given value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: first low/middle/high value seen in the row/column
  
setFirstSeenModular(row,col,rc,value): asserts the first digit with the same modulus as value seen in the row/column is the given value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: first value equal to 0/1/2 mod 3 seen in the row/column

Flat Mates
----------
setFlatMate(base,above,below): for every appearance of "base", one of the digits in above must appear above it and/or one of the digits in below must appear below it
  base: digit
  above: list of digits
  below: list of digits
  
setDutchFlatMates(): sets the classic Dutch flat mates, with base digit 5, above digit 1 and below digit 9

Forbidden Consecutive Sums
--------------------------
setNoConsecutiveSum(list): asserts that no pair of adjacent cells can have digits that sum to a value in the list
  list: list of forbidden sum values
  
setNoSeven(): asserts that adjacent cells may not sum to 7

Fortress
--------
setFortress(list): creates a Fortress constraint on a group of cells
  list: list of cell specifications
  
Friendly Cells
--------------
setFriendly(cell): creates a friendly cell, i.e., one whose value matches one or more of its row, column, or box number
	cell: single cell specification
	
setFriendlyArray(list): set multiple friendly cells
	list: list of cell specifications
	
setUnfriendly(cell): creates a cell that is not friendly, i.e., its value does NOT match row, column or box
	cell: single cell specification
	
setUnfriendlyArray(list): set multiple unfriendly cells
	list: list of cell specifications

setFriendlyNegative(): assert a negative constraint, namely that cells not marked friendly are NOT friendly

Full Rank
---------
setFullRank(row,col,rc,value): treating all 36 rows and columns (in both directions) as 9-digit integers, with most significant closest to the clue, and placing these values in numerical order, clue asserts that the associated row/column is the value_th smallest in the ordering, so 1 is the smallest, and 36 is the largest
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: rank of this row/column in the ordering
  
NOTE: full rank clues are only implemented for 9x9 boards or smaller, with digit set a subset of {0..9}. There are several differing but reasonable interpretations of how to deal with multi-digit numbers and full rank, sufficiently incompatible to prevent a unified attempt to implement here.

Genetics
--------
setGenetic(list): applies a genetic constraint to the cells: daughter must inherit parity/entropic rank from parents, and must inherit at least one from each
	list: a list of three cell specifications - first two are parent cells, last is daughter cell specification

setGeneticArray(list): applies genetic constraint to multiple specification lists
	list: a list of lists of cell specifications, where each element of the list is formatted per the setGenetic guidelines
 
Given Digits
------------
setGiven(cellVal): set the value in a particular cell
  cellVal: an extended cell specification that includes the value to be set. Shorthand is possible.
    Example: 289, '289' and (2,8,9) all designate a 9 given in row 2, column 8
	
setGivenArray(list): set multiple given digits
  list: a list of cellVal specifications; see setGiven
  
Global Entropy
--------------
setGlobalEntropy(): assert the Entropy condition on all quads. Effectively the same as setting entropy quads on all quads; see set EntropyQuad

setGlobalModular(): same as Entropy, but with modular digit grouping {1,4,7},{2,5,8},{3,6,9}

Global Neighbor Sums
--------------------
setGlobalNeighborSum(sums,exceptions): asserts that every cell with a digit not in exceptions must have an orthogonal neighbor with which it sums to a value in sums
  sums - list of allowed sums
  exceptions - list of digits excepted from the sum requirement

Global Whispers
---------------
setGlobalWhispers(diff,gle): assert a global whispers constraint: every cell has at least one neighbor with which it has a difference of at least, equal to, or at most diff.
  diff: The difference required. Default is 4
  gle: Specifies whether difference with neighbor must be greater than (2, use class variable GE), equal to (1, use class variable EQ) or less than (0, use class variable LE) diff. Default is 2, greater than.

Gurth's Symmetric Placement
---------------------------
Asserts that the the grid has symmetry based on 180 degree rotation plus some permutation of the digits.
setGSP(pairs): assert the GSP constraint
  pairs: a list of lists of pairs of digits whose placement implements the symmetry. Default is pairs that sum to the grid size + 1, e.g. (19,28,37,46). Computationally, this list does NOT need to be complete, so one could use this to assert that everywhere a 1 appears, a 7 appears in the rotational symmetric position, and leave it at that. Don't know if that makes for an interesting puzzle though.

setRotationalPairs(): assert the rotational pairs contraint: each digit has a partner digit which is always placed in cells under a 180 degree rotation. Like GSP, but pairs are not asserted in advance

Hanging Sums
------------
This is a function which is probably overloaded with capability, but generically, it allows the setter to define outside sum clues
which give the sum of some selection of digits, up to some terminator. The syntax is:
setHangingSum(row,col,rc,value,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,comparator=EQ,forceTermination=True,failedTerminationBehavior='partial')
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the sum of all the digits select by selectSummands which occur before a terminating cell
 
  selectSummands: a *list* of conditions (tuples) which describe whether or not to select certain cells into the sum. Generically,
  each tuple starts with a sting containing a property name, and is followed by values specific to that property. Note that multiple
  selection criteria may be given, and they are combined with a logical AND, so a cell must meet ALL given conditions to be included
  in the sum. selectSummands should probably not be empty to ensure countSolutions works correctly; use 'All' to prevent.
    
	Property: 'All'
	  This is a null property...all positions match.
	  
	Property: 'Location'
	  For this property, we are picking cells based on their position within the clued row/column.
	  Values[0]: A comparator: use the class variables GE, EQ or LE, or NE, or the string 'Indexed'
	  Values[1]: For comparators, provides the limit of comparison for fixed locations in the column; for index, provides a cell which indexes the location to be selected
	  So for example, ('Location',p.GE,4) would include all cells in the two boxes not adjacent to the clue. Yes, this is just a cage. I get it.
	  This property can be extended with additional value specifications, all of which will be joined with logical OR, so for example, the tuple ('Location',EQ,1,'Indexed',1) selects the first cell, and the cell indexed by the digit in the first cell. If multiple criteria point to cell, it is only selected once...its value is not multiplied.
	
	Property: 'LocationSkip'
	  Hah, it's not just cages.
	  For this property, we can pick every other, every third, etc. cell
	  Values[0]: Skip number, 2 skips every other, etc.
	  Values[1]: Start number, cell in (0...skip-1} to start at
	
	Property: 'Magnitude'
	  For this property, we select digits based on whether they're big or small.
	  Values[0]: A comparator. Again, NE and EQ don't seem particularly useful, but I'll put em in anyway
	  Values[1]: Value for comparison
	
	Property: 'Parity'
	  For this property, we will pick cells based on parity.
	  Values[0]: Use any comparator class variable: NE, EQ, LE, GE
	  Values[1]: Use 0 for even, 1 for odd. Or you can use the Even/Odd class variables.
	
	Property: 'Entropy'
	 For this property, we pick cells based on Entropy class: low: 1,2,3, middle: 4,5,6, high: 7,8,9
	 Values[0]: Use any comparator class variable: NE, EQ, LE, GE
	 Values[1]: Values for comparison: again, use class variables Low, Middle, High
	
	Property: 'Modular'
	 For this property, we pick cells based on Modulus class: 1: 1,4,7, 2: 2,5,8, 3: 3,6,9
	 Values[0]: Use any comparator class variable: NE, EQ, LE, GE. Mathematically, LE and GE don't really make much sense, but they work.
	 Values[1]: Values for comparison: again, use class variables Low, Middle, High
	
	Property: 'Primality'
	For this property, we pick cells based on whether their digit is prime or not. Which brings up the 1 problem.
	By default, "prime" is 0: 2,3,5,7; "maybe kinda" is 1: 1; "not prime" is 2: 4,6,8,9. Like modular, even though the LE and GE comparisons don't really make sense, you can use them. The behavior of 1 can be configured with the configurePrimality method.
	
	Property: 'MatchParity', 'MatchEntropy', 'MatchModular', 'MatchPrimality'
	For this property, we pick cells if they match the given property of the cell specified in value
	Value: index of cell in line whose property to match (e.g., 1 is first cell, 2 is second, etc.)
	
	Property: 'ParityChange', 'EntropyChange', 'ModularChange', 'PrimalityChange'
	For this property, we pick a cell if it is part of a change in the given property
	Value: 'before' picks the first cell in the change, 'after' picks the second
	
	Property: 'Uniparity'
	For this property, we pick all cells of one parity or the other
	Value: none given, pass tuple as a list, i.e. ['Uniparity']
	
	Property: 'DigitSet'
	For this property, we pick cells if their corresponding digit is in the given list of digits
	Value: list of digits to match
	
	Property: 'BeforeDigits'
	For this property, we pick cells that appear before any digit in a given list in the row/column, as seen from the clue
	Value: list of digits to seek
	
	Property: 'AfterDigits'
	For this property, we pick cells that appear after any digit in a given list in the row/column, as seen from the clue
	Value: list of digits to seek
	
	Property: 'NextToDigits'
	For this property, we pick cells that appear next to any digit in a given list in the row/column, as seen from the clue
	Value: list of digits to seek
	
	Property: 'DigitInstance'
	For this property, we select cells based on how many times their digit has appeared in the list.
	Values[0]: A comparator: use the class variables GE, EQ or LE, or NE.
	Values[1]: Value for comparison
	
	Property: 'NoRepeats'
	For this property, we select cells only if their digit does not repeat in the list.
	
	Property: 'ConsecutiveBefore','ConsecutiveAfter','ConsecutiveNeighbor'
	For these properties, we pick digits that are consecutive with the digit before, after, or either (respectively) in the line
	
	Property: '(Parity|Entropy|Modular|Primality)(Neighbor|Before|After|All|None|Both|Neither)'
	Sorry for Regex description here, but there are actually 28 different possibilities, as any characteristic in the first list can be paired with any location in the second list to create a property, e.g., ParityAfter, ModularNone, etc.
	For these properties we pick digits whose described neighbors meet the associated property matching condition
	  Neighbor: either the digit before or after, possibly both
	  Before: the digit before
	  After: the digit after
	  All: all neighbors, possibly just one match if digit is at the end of a line
      None: no neighbors match, possibly just one non-match if digit is at the end of a line
	  Both: cell must have two neighbors, and both must match
	  Neither: cell must have two neighbors, and neither may match
	  
	Values[1]: Possible values are not given, an integer, the string 'Fixed' or the string 'Indexed'
	  If no second argument is given, the neighbor digits will be considered to match if they have the same	parity/entropy/etc. as the digit under consideration.
	  If the second argument is an integer, the property for each neighbor is compared for equality against the given value.
	  If the second argument is 'Fixed', then the property is compared against the same property of the Nth digit in the list, where N is the third argument.
	  If the second argument is 'Indexed', then the property is compared against the same property of the cell whose position is indexed by the Nth digit in the list, where N is the third argument.
	Values[2]: A position in the list, must be preceded by 'Fixed' or 'Indexed'.
	
	For example: ['EntropyBefore'] will match all digits whose predecessor is in the same entropy stratum
	('ParityBoth',0) will match all digits that have two neighbors when both of those neighbors are even, regardless of the parity of the digit under consideration. ('ModularNeither','Fixed',1) will match all digits which are not adjacent to a digit of the same residue class as the first digit in the list.

	Property: '(Parity|Entropy|Modular|Primality)Run'
	I'm done apologizing for the regex descriptions :-) For this property, we split the cells into contiguous runs with the same value of the selected property, and allow the user to select all digits in one or more of these groups.
	Values[0]: This parameter shapes how we count the runs. There are three possible syntaxes:
	  ['Any'] - each run is counted, regardless of the value of the property for the run
	  
	  ('Property',comparator,value) - only counts groups which match the property comparison with a fixed value; e.g. ('Property',p.EQ,1) counts only the runs where property equals 1
	  
	  ('Cell',comparator,index) - only counts groups which match the property comparison with a value in the given cell; e.g.,
	  ('Cell',p.NE,1) counts only the runs whose property is not equal to that property of the first cell in the list (1-based)
	  
	Values[1]: This parameter picks which runs we select. It may be a single integer, the string 'Last', or a list containing one or more of these. 
	
	Property: '(Ascending|Descending)Run'
	For this property, we split the cells into contiguous runs of increasing or decreasing digits, and allow the user to select the digits from one or more of these groups.
	Values[0]: This parameter picks which runs we select. It may be a single integer, the string 'Last', or a list containing one or more of these. 
	
	Property: 'Skyscrapers'
	For this property, we select a cell if it is the maximum of all cells which have been seen thus far. This corresponds to the concept of being "seen" in traditional Skycrapers rules.
	
	Property: 'RelatedDigit'
	For this property, we select digits having a given relationship with a fixed cell in the line.
	Values[0]: Location of the base digit along the line (one-based)
	Values[1]: A comparator: use the class variables GE, EQ or LE, or NE
	Values[2]: Scale, an integer multiplied by the digit in the base cell to determine the threshold for comparison
	Values[3]: Shift, an integer add to the (scaled) digit in the base cell to determine the threshold for comparison
	
	Property: '(Majority|Minority)(Parity|Entropy|Modular|Primality)'
	For this property, we select the digits with the property that has the largest or smallest *non-zero* incidence on the line. In case two or more classes are tied for the extreme count, ALL digits in those classes are selected.
	
  selectTerminator: a *list* of conditions (tuples) which describe when the sum should stop. As with summand selection,
  each tuple starts with a sting containing a property name, and is followed by values specific to that property. Note that multiple
  selection criteria may be given, but for termination they are combined with a logical OR. There are three styles of termination, defined
  by the terminateOn parameter, described below. Currently supported properties:
    Terminator: 'Last'
	Terminate at the last cell in the column
	
	Terminator: 'Fixed'
	We're terminating at a fixed index in the row/column, e.g. the first six cells.
	Value: index at which to terminate sum
	
	Terminator: 'SumReached'
	Terminate when a sum of the cell values (regardless of whether our target is a sum, count or other) is reached or exceeded
	Value: target sum to stop at
	Example: This could be used to find all of the even digits in the first N digits whose sum does not exceed 15.
	
	Terminator: 'DigitReached'
	Terminate when a fixed digit is reached
	Value: target digit to stop at 
	
	Terminator: 'DigitSetReached'
	Terminate when some numbered instance of a digit set is reached
	Values[0]: list of target digits
	Values[1]: nth instance of target to stop at
	
	Terminator: '(Parity|Entropy|Modular|Primality)(Change|Repeat)Reached'
	Again, apologies for the regex notation, but there are 8 possible combinations here. This terminator keeps track of the number of changes or repeats in some property (parity, entropy, etc.), and terminates on a specified instance of said change.
	Value: nth instance of target
	Note: in any case, the terminating cell is the *second* in the pair where the change/repeat is determined, so the first cell can never be a terminator.
	
	Terminator: 'Indexed'
	Terminate at a value indexed by a set of indices
	Values[0]: list of cell indexes whose digit can be used to index the length of the sum
	Values[1] (optional): determine how to pick which of the index cells defines the sum. Options are 'Any' (default), 'Largest' or 'Smallest'
	  'Any' - any sum defined by a digit in any index cell may match the clue
	  'Largest' - the largest digit in the index cells defines the length of the sum that matches the clue
	  'Smallest' - the smallest digit in the index cells defines the length of the sum that matches the clue
	
	Terminator: 'RepeatReached'
	Terminate when some numbered instance of a repeated digit is reached
	Value: May be an integer to give a specific number of repeats, or may be the string 'Last' to indicate termination at the last repeat.
	
	Terminator: 'RelatedDigit'
	Terminate when some instance of a digit having a given relationship with a cell in the line is met.
	Values[0]: Location of the base digit along the line (one-based)
	Values[1]: A comparator: use the class variables GE, EQ or LE, or NE
	Values[2]: Scale, an integer multiplied by the digit in the base cell to determine the threshold for comparison
	Values[3]: Shift, an integer add to the (scaled) digit in the base cell to determine the threshold for comparison
	Values[4]: The numbered instance on which to terminate
	  Example: ('RelatedDigit',-1,p.GE,2,0,3) would terminate at the third digit in line that is at least double the digit (plus 0) in the last cell
	  
	Terminator: 'ModelVariable'
	Terminate at a location given in a solver model variable (1-based). This is advanced stuff.
	Value: model variable
	
  terminateOn: by default, the sum will terminate at the first cell that matches one of the termination criteria. This can also be set explicitly
    by the argument terminateOn='First'. Additional possibilities are:
	terminateOn='Last' - Uses the last cell which meets the termination criteria
	terminateOn='Any' - Allows the solver to use any legitimate termination cell to match the clue; this is good for clues like parity party,
	                    where any of the possible termination criteria may be used.
  
  includeTerminator: by default, the sum will include the cell which signals that the sum is to be terminated into the sum. To change this
  behavior and sum only up to, but not including, the terminator, set includeTerminator=False. Word to the wise: not including the terminator
  may give wonky results if the first cell is the terminator. Caveat emptor.
  
  comparator: by default equality, but can be set to LE, GE or NE using class variables.
  
  forceTermination: the default behavior is that if no terminator is found (e.g., terminator is 'RepeatReached' on a line with no repeats), then the solver considers there is no solution to the puzzle. If forceTermination is set to False, the solver does not fail if no cell meets the termination condition; behavior depends on the failedTerminationBehavior argument...see below.
  
  Example:
  p.setHangingSum(1,2,p.Col,14,[],[('Fixed',1),('DigitSetReached',[2,4,6,8],1),('DigitSetReached',[1,3,5,7,9],1)],terminateOn='Any')
  
  This sets a parity party constraint. There are no selectSummands, so all digits are included in the sum. The sum can stop after the first digit,
  or continues until it reached an even digit, or until it reaches an odd digit. Parity party can also be implemented like so:
  
  p.setHangingSum(1,2,p.Col,14,[],[('Fixed',1),('ParityChangeReached',1)],terminateOn='Any')
  
  The sum can again terminate in the first cell, or it continues to the first parity change.
  
  failedTerminationBehavior: There are two options: 'partial' and 'zero', with 'partial' being the default. For 'partial', the solver counts/sums to the end of the specified row/column/line for purposes of comparison with 'value'. If this option is selected, the last cell on the line is NOT considered a terminator for purposes of "includeTerminator", so *all* cells are included. For 'zero', the solver insists that 'value' be 0...this can be a useful way for testing negative conditions, since the value on failure will be predictable.
  
Related functions:
setHangingCount(row,col,rc,value,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,comparator=EQ,forceTermination=True) - counts the number of digits matched, instead of their sum

setHangingAverage(row,col,rc,value,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True) - counts the average of the matched digits

setHangingInstance(row,col,rc,values,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,negativeConstraint=False) - determines if the selected digits match the digits given in values
  All arguments are the same as hanging sum, except
  values: a list of values to be found meeting the conditions
  negativeConstraint: assert that the digits in values are the only digits which meet the selection criteria

setRayCount(row,col,rc,value,selectInitiator,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,comparator=None,forceTermination=True,includeSelf=True,backward=True,forward=True,failedTerminationBehavior='partial') - in a row or column, calculates a count which has an indefinite starting point along the line, and may select cells in both directions from the starting cell
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the count of selected cells (per the selection criteria) on the rays emanating from an initiator cell (to be determined by the solver) up to some terminating cells
  
  selectInitiator: gives the criterion which determines which the base cell in the row/column is. Currently supported methods:
  Initiator: 'Fixed'
	We're initiating at a fixed index in the row/column, e.g. the third cell from the start.
	Value: index at which to initiate counts
	
  Initiator: 'DigitReached'
	Initiate at a fixed digit
	Value: target digit to start at
	
  Initiator: 'Indexed'
	Initiate at a value indexed by a cell in the row/column
	Value: position of the cell whose value is used to indicate the starting position
	
  selectSummands, selectTerminator, terminateOn, includeTerminator, comparator and forceTermination are as in setHangingSum
  
  includeSelf: Default is True; the base cell is counted once as part of the overall count. If False, cell is not counted.
  
  backward: Default is True; the ray from the initiator cell back to the clue is counted according to the selection and termination criteria. If False, this ray is not included in the count
  
  forward: Default is True; the ray from the initiator cell away from the clue is counted according to the selection and termination criteria. If False, this ray is not included in the count
  
  failedTerminationBehavior: If a ray fails to meet one the termination criteria, and forceTermination is False, there are two possible behaviors. The default is 'partial', where we evaluate against the count of the selected values to the end of the line; effectively the end of the line becomes the terminator. The other possible value is 'zero', in which case the count is evaluated against 0. This is useful for cases where we will terminate in one direction or the other, but we don't know which in advance. A good use case (using raySum) is:
    p.setRaySum(1,1,p.Col,24,('DigitReached',1),[['All']],[('DigitReached',9)],includeTerminator=False,forceTermination=False,includeSelf=False,failedTerminationBehavior='zero')
  which is just a long way to write a sandwich sum clue.
  
setRaySum(row,col,rc,value,selectInitiator,selectSummands,selectTerminator,terminateOn='First',includeTerminator=True,comparator=None,forceTermination=True,includeSelf=True,backward=True,forward=True,failedTerminationBehavior='partial') - same as setRayCount, but compares to the sum of the matching cells on the chosen rays

Hidden Clones
-------------
setHiddenClones(list,number): assert that the region of cells defined via list has at least number exact clones (same digits in same position, no rotation or reflection)
  list: list of cell specifications
  number: minimum number of clones to assert

In Order
--------
setInOrder(row,col,rc,values,adjacent): when viewed from the clue location, the digits in values are seen in order
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: list of digits in the order that they are to be seen
  adjacent (optional): Defaults to False. If True, values must be in a contiguous group of cells.

Indexed Pair Sums
-----------------
setIndexedPairSum(row,col,uldr,value): In a cell row,col containing digit N, an arrow points to a cell N cells away whose sum with N is value
  row,col: The coordinates of the cell with the arrow
  uldr: the direction the arrow points; use Up, Down, Left, Right class variables
  value: the sum of the two cell values

Indexing (159)
--------------
****NOTE****
Older versions of OR Tools had a bug (https://github.com/google/or-tools/issues/3670) which caused the same solution to be reported multiple times. This has been fixed as of version 9.6.

setIndexRow(row,neg=False,inlist=[]): set an index row, namely one which indicates the position of the digit corresponding to the row within some subset of columns
  row: the row (1-9) used as an index. By default, all column positions index
  neg (optional): if a column position is indicated as not indexing, then position indicate specifically does NOT indicate the position of the digit. Default is False.
  inlist (optional): a list of which column positions (1-9) are indexing, with columns not in the list NOT indexing. Note: if inlist is not given, and neg=True, then code assumes *NO* cell in the row indexes. If inlist is not given, and new is True, or not given, then code assumes *ALL* cells in the row index.
  Example: If we call setIndexRow(5,True,[1,2,3,4,5,6,7,8]), then in all but the rightmost column, the entry in row 5, column X indicates which row contains a 5 in that column. So if 5,1 is a 2, then 2,1 must be 5. In the rightmost column, the 5 CANNOT appear in the row indicated by the entry in row 5. Specifically if 5,9 is a 3, then the entry in 3,9 CANNOT be a 5.

setIndexColumn(row,neg=False,inlist=[]): set an index column. See setIndexRow for details of the mechanics
  Example: The traditional 159 ruleset is implemented with the calls:
  setIndexColumn(1)
  setIndexColumn(5)
  setIndexColumn(9)
  
Irregular Sudoku
----------------
Note: for ALMOST all intents and purposes, regions are no different from killer cages of size 9. But regions are respected by regions sum lines, where cages are not.

To implement an irregular Sudoku puzzle, call the puzzle constructor with the irregular flag set, e.g.,
p = ORsudoku.sudoku(boardSizeRoot,irregular=True)

setRegion(list): creates an Irregular Sudoku region
	list: list of cell specifications
	
set Regions(list): create multiple irregular Sudoku regions
	list: list OF LISTS of cell specifications

Isotopes
--------
Note: this constraint is only accurate for 9x9 puzzles with boxes...created by rockratzero
setRRZRotor(): asserts that if any two boxes have the same center cell, then the other digits in each box appear in the same order, modulo rotation

Japanese Sum Sudoku
-------------------
To model a Japanese Sum Sudoku puzzle, you must use the class japaneseSumSudoku, e.g.

from japaneseSumSudoku import japaneseSumSudoku
p = japaneseSumSudoku(boardSizeRoot,numberOfColors,irregular,digitSet)
	boardSizeRoot is the edge size of a box, so 3 for standard sudoku
	numberOfColors is the number of different colors that can be shaded...does not count unshaded as a separate color. Defaults to 1.
	irregular - set to true if regions in the sudoku are irregular. The regions are then defined with setRegion...see Irregular Sudoku. Defaults to standard boxes.
	digitSet - allows setting with an alternate digit set.

In this class, you can use the following method to set constraints
setJapaneseSum(row,col,rc,value,includeColors): sets a Japanese sum constraint
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: A list of values representing the sums in a clue. If there is only one color, this list can be given as a list of integers, e.g., [2,5,17]. However, if multiple colors are used, the list elements should be tuples (sum,color), where the sum is the sum of digits in the shaded group, and color is the color. Colors are given as integers starting at 1 (internally, unshaded is color 0, but it has special rules).
  includeColors: A list of color values (integers 1..numberOfColors) which must appear in the row/col
  
  Ambiguous clues *are* supported: if a clue is given with a sum of zero, then the total sum of the shaded group is not checked. If a clue is given with a color of zero, then there must be a shaded group with the given sum, but the color is not checked. If both sum and color are zero, there must be another shaded group, but sum and color are unchecked.
  
If you wish to change the default color scheme for the printout of findSolution, this can be done with the setColorMap method. HOWEVER, you need to import the colorama class variables into your code as:

from colorama import Fore,Back

Then, you can set your color map as in this example:
p.setColorMap([(Fore.WHITE,Back.CYAN),(Fore.BLACK,Back.WHITE),(Fore.BLACK,Back.GREEN),(Fore.WHITE,Back.BLACK)])

In this example, the *unshaded* cells will be white numbers on a cyan background. Color 1 will be black digits on a white background, etc.

This class supports several assertions that can be used for lookahead checking:

assertShaded(cell): asserts that an individual cell must be shaded, without specifying color
	cell: single cell specification

assertShadedArray(list): asserts that a list of cells is shaded, without specifying colors
	list: list of cell specifications
	
assertUnshaded(cell): asserts that an individual cell must not be shaded
	cell: single cell specification

assertShadedArray(list): asserts that a list of cells is unshaded
	list: list of cell specifications
	
assertColor(cellC): asserts that a cell is shaded with a specific color
	cellC: extended cell specification that includes row,col,integer color
	
assertFixedColorArray(list,color): asserts that a list of cells are all colored color
	list: list of cell specifications
	color: integer denoting a single color

assertColorArray(list): a list of color assertions	
	list: a list of cellC specfications, see assertColor above

Keypad King Lines
-----------------
setKeypadKingLine(list): creates a keypad king line constraint (adjacent digits must be a king's move apart on a telephone keypad). Designed by Zegres
  list: a list of cell specifications
  
Keypad Knight Lines
-------------------
setKeypadKnightLine(list): creates a keypad knight line constraint (adjacent digits must be a knight's move apart on a telephone keypad). Designed by Zegres.
  list: a list of cell specifications
  
Killer Cages
------------
setCage(list,value): creates a killer cage with all cell values distinct
  list: list of cell specifications indicating the cells in a killer cage
  value (optional): if given, indicates the sum of the digits in the cage
  Note: sum dots can be implemented computationally with a killer cage, since this method does not require any particular relationship amongst the cells.
  
setRepeatingCage(list,value): creates a killer cage where values may repeat
  list: list of cell specifications indicating the cells in a killer cage
  value: indicates the sum of the digits in the cage
  
setAmbiguousCage(list,values,repeating=False): creates a killer cage whose sum is one of a given set of values, to be determined by the solver
  list: list of cell specifications indicating the cells in a killer cage
  values: the list of possible sums the cage could take on
  repeating: by default digits are not allowed to repeat; setting repeating=True permits repeats

setPsychoKillerCage(list,value): creates a psycho killer cage, where the elements of the cage *provide a reference* to the digit in the same relative position in the box indicated by the cage element, and the sum of the referred digits is given
  list: list of cell specifications of cells in the cage
  value: sum of the referred cells
  
setPuncturedCage(list,value,puncture): creates a punctured cage, where the value is the sum of all but puncture digits in the cage
  list: list of cells in the cage
  value: sum of subset of the cells
  puncture: (optional, default is 1) number of cells punctured from the sum
  
setKnappDanebenCage(list,value): creates a killer cage with all cell values distinct, where the sum of the digits is either one greater or one less than the given digit
  list: list of cell specifications indicating the cells in a killer cage
  value: indicates the sum of the digits in the cage, plus or minus 1.
  
setRankedCage(cellList,rankList): creates a killer cage with no repeats, but no specified sum. Rather, individual cells
   within the cage are ranked from smallest (1), to largest (n, number of cells in cage), and any subset of ranks may be
   clued.
   cellList: list of cell specifications
   rankList: list of tuples, where the first element of a tuple is the index of the clued cell in cellList (1-based, so first cell is 1), and the second element is its rank in the cage (1 is smallest, 2 is second smallest, etc.)
  
Kropki and Kropki Pairs
-----------------------
setKropkiWhite(cellHV): creates a white Kropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiBlack(cellHV): creates a black Kropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiGray(cellHV): creates a gray Kropki dot, which can be either a white or black dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiWhiteArray(list): creates multiple white Kropki dots
  list: list of cellHV specifications, see setKropkiWhite

setKropkiBlackArray(list): creates multiple black Kropki dots
  list: list of cellHV specifications, see setKropkiBlack

setKropkiGrayArray(list): creates multiple gray Kropki dots
  list: list of cellHV specifications, see setKropkiGray

setKropkiArray(list): creates multiple Kropki dots
  list: list of cellHVWBG specifications, which include a cell spec, the HV spec as given in setKropkiWhite, and a WBG spec, specifying the color of the dot. When given as a tuple, the White, Black and Gray variables can be used to specify W/B. Shorthand is possible, with white being 0, black 1, and gray 2.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
setAntiKropki(cellHV): asserts that the digits are neither consecutive or in a 2-to-1 ratio by default...uses kropkiDifference and kropkiRatio if these have been changed
	cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V.
setAntiKropkiWhite(cellHV): same, but for white dots only
setAntiKropkiBlack(cellHV): same, but for black dots only

setAntiKropkiArray(list): creates multiple anti-Kropki constraints
  list: list of cellHV specifications, see setKropkiWhite
setAntiKropkiWhiteArray(list): same, but for white dots only
setAntiKropkiBlackArray(list): same, but for black dots only
  
setKropkiNegative(dominoesOnly): implements true Kropki rules with a negative constraint
setKropkiWhiteNegative(dominoesOnly): sets a negative constraint on only white Kropki dots
setKropkiBlackNegative(dominoesOnly): sets a negative constraint on only black Kropki dots
  dominoesOnly is an optional parameter, defaulting to False, which sets the negative constraint only on pairs of adjacent cells such that neither cell lies on a positive clue...if one thinks of the pairs as dominoes, no additional non-overlapping dominoes can be placed
  
  Note: this is probably a super edge case, but a 1/2 pair can be either a white or block dot. If you define a black dot in a puzzle with a negative constraint on white dots, then the black dot CAN be a 1/2, despite there being no white dot there. If this is not desired behavior, then just exclude ones from both cells with setPencilmarks(). Problem solved. As inelegantly, but easily, as possible.
  
To change the values used for difference for white dots, and ratio for black dots, you can use the following methods:
setKropkiDifference(value)
setKropkiRatio(value)

The values can be reset to their defaults by calling them with no argument. All dots added subsequently to these calls will use the new values, without changing constraints already entered. HOWEVER, if a negative constraint is applied, it will ALWAYS use the final set value of these two variables to apply the negative constraint against.

setGammaEpsilon(): implement Gamma Epsilon rules, equivalent to setKropkiDifference(5) & setKropkiRatio(3)

Remote Kropki Arrows are similar to dots, but an arrow in a cell points to the cell indexed by the digit in the arrow cell with which it shares a Kropki relationship. The following methods are supported, all analogous to their standard Kropki counterparts:
setRemoteKropkiWhite(cellDir)
setRemoteKropkiBlack(cellDir)
setRemoteKropkiGray(cellDir)
setRemoteKropkiWhiteArray(list) - list of cellDir
setRemoteKropkiBlackArray(list) - list of cellDir
setRemoteKropkiGrayArray(list) - list of cellDir
setRemoteKropkiArray(list) - list of cellDirBWG
setRemoteKropkiDifference(diff)
setRemoteKropkiRatio(ratio)
  cellDir: an extended cell specification which adds the Direction parameter: All parameters can be in a tuple, and these can use the Up, Down, Left, Right specification for class variables. Shorthand is possible, appending 0 to a cell spec to indicate Up, 1 for Down, 2 for Left and 3 for Right
  Example: 251, '251' and (2,5,p.Down) all specify an down arrow in cell 2,5
  
  cellDirBWG: extends the cellDir spec with a color attribute. In a tuple, can use the class variables Black, White and Gray. Shorthand is possible, with 0 to indicate White, 1 for Black and 2 for Gray.

Line Sum Lines
--------------
setLineSumLine(list): asserts that one of the cells on the line is the sum of all remaining cells on the line. See Missing Arrow constraints under Arrows.
  list: a list of cell specifications

Little Killers
--------------
setLittleKiller(row1,col1,row2,col2,value): sets a little killer diagonal constraint
  row1,col1: the cell spec of the first cell in the little killer diagonal, next to the clue
  row2,col2: the cell spec for the second cell in the diagonal (this seemed easier than some arbitary spec to define diagonals)
  
Lockout Lines
-------------
setlockoutLine(list): creates a lockout line constraint
  list: a list of cell specifications
  
Logic Bombs
-----------
setLogicBomb(row,col): asserts a cell is a logic bomb, so that it and its 8 knightly neighbors are all distinct digits
  row,col: cell specification
  
assertNumberOfLogicBombs(n): asserts that there are at least n logic Bombs in the grid (10 is max for 9x9)
  n: positive integer

Lot Lines
---------
setLotLine(inlist,lotIndex,property): asserts that the cell at lotIndex on the line counts the number of instances of property on the line
  inlist: list of cell specifications
  lotIndex: the index of the cell along the line (1-based, from the front) containing the lot cell
  property: the property to count. Currently supported:
    'ParityChange' - count the number of parity changes between digits along the line
	  (analogous 'EntropyChange', 'ModularChange', and 'PrimalityChange' also supported)
	'MatchParity' - count the number of cells on the line whose parity matches the lot cell
	  (analogous 'MatchEntropy', 'MatchModular', and 'MatchPrimality' also supported)
	'UniqueDigits' - count the number of unique digits appearing on the line
	'Even'/'Odd' - count number of even/odd cells on line
	'Low'/'Middle'/'High' - count number of cells with low/middle/high entropy on line

Magic Lines
-----------
setMagicLine(list): create a magic line, where each set of four consecutive cells along the line contains one or more set of three consecutive cells whose sum is 15
  list: list of cell specifications

Magic Squares
-------------
setMagicSquare(cell): creates a magic square with given cell the upper left corner
  cell: single cell specification

Max Ascending
-------------
setMaxAscending(row,col,rc,value): sets a max ascending constraint, specifying the longest consective run of increasing digits in the row/col, looking from the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the length of the longest run of increasing digits in the row/col
  
setMaxAscendingRun(row,col,rc,value,lengthTest,valueTest): like MaxAscending, but more flexible in defining length and value
  row,col,rc,value: as in MaxAscending
  lengthTest: 'cells' or 'sum' - one can define "longest" by either number of digits in the run, or the sum of the digits in the run; e.g. 19 would be "longer" than 234
  valueTest: 'cells' or 'sum' - regardless of how one defines length, one can test the value of the number of digits in the run or the sum of the digits in the run

Maximum Runs
------------
setMaximumRun(row,col,rc,value,length): asserts that in a row/column, the maximum sum of any "length" consecutive digits is value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: maximum sum achievable
  length: number of consecutive digits to sum. Optional, default is 3.
  
setMaximumTriplet(row,col,rc,value): original formulation, maximum Run with length 3

MaxMin Sum Cages
----------------
setMaxMinSumCage(list,value,repeating=False): asserts the sum of the largest and smallest digits in cage defined by list is value
  list: list of cell specifications
  value: sum of largest and smallest digits in cage
  repeating (optional): True if digits may repeat in cage, default is false
  
set MaxMinQuadSum(row,col,value): a shorthand for a cage around a 2x2 quad
  row,col: Cell specification
  value: sum of largest and smallest digits on quad
  Shortcut notation is possible, e.g., MaxMinQuadSum(3312) will set a max-min sum of 12 on quad 3,3
  
setMaxMinQuadSumArray(list): sets multiple MaxMain Quad Sum constraints
  list: list pf shorthand specifications for cell/values

Median Cages
------------
setMedianCage(list,value): sets the median value in the region (which must appear in the region)
	list: list of cell specifications
	value: target median value

Min-Max
-------
setMinCell(cell): assert a cell is smaller than all orthogonally adjacent cells
  cell: single cell specification
  
setMaxCell(cell): assert a cell is larger than all orthogonally adjacent cells
  cell: single cell specification
  
setMinArray(list): set multiple minimum cells
  list: list of cell specifications
  
setMaxArray(list): set multiple maximum cells
  list: list of cell specifications
  
setMinMaxCell(cellMM): set a minimum or maximum constraint
setMaxMinCell(cellMM): set a minimum or maximum constraint
  cellMM: an extended cell specification which adds the minmax parameter. All parameters can be given positionally, or in a tuple, and these can use the Min and Max variables for the minmax specification. Shorthand is possible, appending 0 to a cell spec to indicate a minimum and 1 to indicate a maximum.
  
setMinMaxCellArray(list): set multiple min/max constraints
setMaxMinCellArray(list): set multiple min/max constraints
  list: list of cellMM specifications; see setMinMaxCell
  
Minimax
-------
setMinimax(row,col,rc,value,length): asserts the sum of the largest and smallest digits in the target range is value
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value that is the minimax sum
  length (optional): by default, the target range is the cells in the region including the cell next to the clue.
                     If length is given, the target range is the first length cells from the cell next to the clue, regardless of regions.
					 
setMaximin(row,col,rc,value,length): asserts the difference of the largest and smallest digits in the target range is value
  Options same as setMinimax

Modular Lines
-------------
setModularLine(list): creates a modular line constraint
  list: a list of cell specifications
  
More-Odd-Than-Even Cages
------------------------
A MOTE cage has more odd digits than even digits, and a METO cage is the reverse

setMOTECage(list): set a MOTE cage
	list: list of cell specifications

setMETOCage(list): set a METO cage
	list: list of cell specifications
	
setEquiparityCage(list): set a cage with an equal number of even and odd digits; see also Capsules
	list: list of cell specifications

setUniparityCage(list): set a cage with enitrely even or entirely odd digits
	list: list of cell specifications

Nabner Lines
------------
setNabnerLine(inlist): assert that there are no two digits lying on the line are the same or consecutive
	inlist: list of cell specifications

Nearest Neighbor
----------------
setNearestNeighbor(row,col,pointers): arrows in a cell point to the orthogonal neighbor that has the closest digit; multiple arrows may occur if two or more neighbors are equidistant
	row,col: the cell in question
	pointers: a single direction, or a list of directions: use class variables Up, Down, Left and Right

Neighbor Sets
-------------
setPosNeighborSet(row,col,prop): assert that this cell has an orthogonal neighbor with which it matches on property
  row,col: the cell in question
  prop (optional): property may be any of 'Parity', 'Entropy', 'Modular', 'Primality', or may be a list of integers, where two cells match if their digits are both in or both out of the set. Property is optional, and defaults to 'Entropy', unless a property has been set with setNeighborSetProperty (below)
  
setNegNeighborSet(row,col,prop): assert that this cell does not have an orthogonal neighbor with which it matches on property

setPosNeighborSetArray(list,prop): sets multiple positive Neighbor Set constraints
  list: list of cell specifications
  prop (optional): property

setNegNeighborSetArray(list,prop): sets multiple negative Neighbor Set constraints
  list: list of cell specifications
  prop (optional): property

setNeighborSetArray(list,prop): sets multiple positive or negative Neighbor Set constraints
  list: list of extended cell specifications, row/column/pn, for positive negative. Use 0 for positive, 1 for negative, or Pos and Neg class variables
  prop (optional): property
  
setNeighborSetProperty(prop): sets the property used by neighbor set constraints; property defaults to 'Entropy', or can be set individually in specific method calls

setNeighborSetNegative(): sets a negative constraint, so that all cells not designated as having a matching orthogonal neighbor will not

Neighbor Sums
-------------
setNeighborSum(cell): asserts a cell is the sum of its orthogonally adjacent neighbors
	cell: single cell specification
	
setNeighborSumArray(list): asserts multiple neighbor sum constraints
	list: list of cell specifications
	
Note: setNeighbourSum and setNeighbourSumArray aliases are supported

Next-to-Nine
------------
setNextToNine(row,col,rc,values,digit): given a set of 1/2 digits on a row/column, these digits must appear in next to the nine in that row/column
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: A list of values to go next to 9; if only one value is given it may be given as an integer
  digit (optional): defines which digit is the one the clued digits must appear next to...defaults to 9
  
setNextToNineSum(self,row1,col1,rc,value,digit): gives the sum of the cells next to the nine in the clued row/column
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: an integer specifying the sum of the cells next to the given digit
  digit (optional): defines which digit is the one the clued digits must appear next to...defaults to 9

No Three in a Row (Parity)
--------------------------
setNoThreeInARowParity(): assert that in any row/column, there are no three consecutive odd digits nor are there three consecutive even digits

Non-Consecutive
---------------
setNonConsecutive(n): sets the global non-consecutive cells constraint
	n: Optional. By default, n=2 and there are no pairs of adjacent cells with consecutive digits. If n>2, then no set of n contiguous cells in a row or column can consists of a set of n consecutive digits.

Numbered Rooms
--------------
setNumberedRoom(row,col,rc,value): sets a numbered room constraint
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell
  Note: for negative digits, the behavior of a Numbered Room is to count cells from the other side of the row/column, a la a reverse Numbered Room
  
setReverseNumberedRoom(row,col,rc,value): sets a reverse numbered room constraint, i.e., If the clue is X, the value is placed in cell X counting from the *other*, non-clue end of the row/column.
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell
  Note: for negative digits, the behavior of a reverse Numbered Room is to count cells from the other side of the row/column, a la regular Numbered Room

Offset Digits
-------------
setOffsetDigit(digit): for each instance of the selected digit, the digit below it is the distance to the given digit in its row
  digit: the digit having this property

Order Sum Cages
---------------
setOrderSumCages(list,slow,repeat): a set of cages with indeterminate sums, but whose sum order increases directly with order in the list
  list: a list OF LISTS of cell specifications
  slow: Optional, default is False. If False, each cage sum must be strictly less than its successor. If True, relationship is less than or equal.
  repeat: Optional, default is False. If False, digits may not repeat in cages. If True, digits may repeat.
  
Outside Clues
-------------
setOutside(row,col,rc,valueList): provides a set of values on a row or column that must appear in that row/column in the first box (region for irregular sudoku) appearing next to the clue; also option for using a fixed number of cells...see setOutsideLength
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  valueList: a list of values to be placed
  
setOutsideLength(num): sets a fixed length for outside clues, independent of regions

setOutsideDiagonal(r1,c1,r2,c2,valueList): provide a set of values that must appear along a diagonal containing r1c1 and r2c2; defaults to limiting diagonal to a region, but canuse a fixed length as well...see setOutsideLength
  r1,c1: Coordinates of cell next to clue
  r2,c2: Coordinates of second cell along the diagonal
  valueList: List of values to appear along the diagonal within the region (default) or a fixed number of cells

Palindrome Lines
----------------
setPalindromeLine(list): creates a palindrome line constraint
  list: a list of cell specifications
  
setParindromeLine(list): creates a parindrome line constraint, where only parity has to match 
  list: a list of cell specifications
  
Parity Count Lines
------------------
setParityCountLine(list): creates a parity count line constraint (inspired by Richard Stolk https://logic-masters.de/Raetselportal/Raetsel/zeigen.php?id=000B15, endpoints contain the number of odd/even digits along the line, in some order))
  list: a list of cell specifications
  
Parity Dots
-----------
Parity dots are placed like Kropki dots, but white dots indicate the adjacent cells are of different parities, while black dots indicate the adjacent cells are of the same parity.

setParityDotWhite(cellHV): creates a white parity dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setParityDotBlack(cellHV): creates a black parity dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setParityDotWhiteArray(list): creates multiple white parity dots
  list: list of cellHV specifications, see setParityDotWhite

setParityDotBlackArray(list): creates multiple black parity dots
  list: list of cellHV specifications, see setParityDotBlack
  
setParityDotArray(list): creates multiple parity dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setParityDotWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
Parity Lines
------------
setParityLine(list): creates a parity line constraint (parity must alternate along the line)
  list: a list of cell specifications
  
Parity Party
------------
setParityParty(row,col,rc,value): sets a parity party constraint, where either the digit next to the clue equals the value, or the sum of all of the values up to and including the first digit that varies in parity from all prior cells
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell

Parity Quads
------------
setParityQuad(cell): creates an parity constraint (both parities must appear) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setParityQuadArray(list): creates multiple parity quad constraints
  list: a list of cell specifications
  
setAntiParityQuad(cell): creates an anti-parity quad constraint (quad is all even or all odd) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiParityQuadArray(list): creates multiple anti-parity quad constraints
  list: a list of cell specifications
  
setParityQuadNegative(): specify that all cells not specifically designated with parity quads do NOT satisfy the parity quad constraint, i.e., all cells must be either odd or even

setParityQuadExclusions(list): sets a list of numbers of *odd* digits not permitted in a 2x2
	list: list of integers defining numbers of forbidden odd digits in a 2x2. Default is [0,4]. Calling the function with no arguments sets the forbidden values back to the default.

All parity quads added subsequently to these calls will use the new values, without changing constraints already entered. HOWEVER, if a negative constraint is applied, it will ALWAYS use the final list of exclusions to apply the negative constraint against.
	
setQuadro(): assert that all 2x2 quads are parity quads; with default settings, sets to the traditional definition of no 2x2 quad having all even or all odd digits

Parity Snakes
-------------
setParitySnake(row1,col1,row2,col2,parity): asserts that there exists a path of constant parity from ro1,col1 to row2,col2
	row1,col1: position of first cell
	row2,col2: position of second cell
	parity: Optional: you may assert the snake has a particular parity with the Odd and Even class variables. By default, the snake may be either parity
	
Note: Parity snakes don't play well with the countSolutions method, due to the implementation. If there are multiple paths, each will be a separate solution, even if the underlying grids are the same. Additional solutions can also be created by cycles off the main path. Each solution will have a uniparity path between the posited endpoints, but the solver cannot readily determine uniqueness yet.
  
Pencilmarks
-----------
setPencilmarks(row,col,values): set pencilmarks (possible values) for a single cell
	row,col: position of cell
	values: list of possible values for the cell
	Note: instead of three positional arguments, one can use a shorthand without punctuation, e.g. 12378 assigns pencilmarks 3/7/8 to cell 1,2.
	
setPencilmarksArray(list): set multiple pencilmark constraints
	list: a list of shorthand pencilmark specifications, e.g. [12123,15289]

Pointing Differents
-------------------
setPointingDifferents(row1,col1,row2,col2,value): asserts that there are only value different digits on the diagonal containing (row1,col1) and (row2,col2)
  row1,col1: the cell spec of the first cell in the little killer diagonal, next to the clue
  row2,col2: the cell spec for the second cell in the diagonal

Pool
----
setPool(value,digit): a dumb constraint that says when reading the digits in the grid from left to right, top to bottom, as a single string, the numbers between instances of digit sum to at most value
  value: the maximum sum of a string of numbers between digit
  digit: optional, defaults to 9...the digit to delimit strings whose sum is calculated

Position Sums
-------------
setPositionSum(row,col,rc,positionSum,valueSum): set a position sum, namely giving the sum (positionSum) of the first two cells adjacent to the clue (determined by row,col) and the sum (valueSum) of the two cells indexed by the first two cells in the column. Neither positionSum nor valueSum is required, and only one can be given.
  row,col: The coordinates of the cell containing the cell next to which the clue values sit
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  positionSum: The sum of the first two cells from the clue direction
  valueSum: The sume of the cells indexed by the first two cells from the clue direction (see Indexing)

Potpourri N-Sums
================
setPotpourriNSums(border,list): for each integer entry in the list, assert that there is a sum of contiguous digits starting from the border which equals this value; moreover, the length of these sums is different for all clued rows/columns on this border
  border: placement of clues; use Top,Bottom,Left,Right class variables
  list: list of clues, integers give sums, non-clued entries should be None, e.g. [15,None,24,None,16,43,5,5]
        unclued rows/columns at the end may simply be omitted

Quadruple
---------
setQuadruple(cellVals): create a quadruple constraint on a 2x2 region
  cellVals: an extended cell specification which adds a list of values appearing in the quad to the cell specification. Shorthand is possible, e.g. 67235 will indicate the quad at 6,7 contains values 2, 3, and 5.
  
setQuadrupleArray(list): set multiple quadruples
  list: list of cellVal specifications; see setQuadruple
  
Quad Max Arrows
---------------
setQuadMaxArrow(cellDir): constraint on a 2x2 points to the unique maximum value in the quad
  cellDir: an extended cell specification which has the coordinates of the 2x2, followed by a direction specification which uses a pair of 01 values to indicate Top/Bottom,Left/Right, in order. The class variables Top, Bottom, Left and Right can be used. So for example, 1401 and (1,4,p.Top,p.Right) both indicate that the cell 15 should be larger than all of 14, 24 and 25.
  
setQuadMaxArrowArray(list): set multiple Quad Max arrow constraints
  list: list of extended cell specifications per setQuadMaxArrow method
  
Quad Max/Min Values
-------------------
setQuadMaxValue(cellValue,unique): constraint on a 2x2 indicating the maximum value in the quad
  cellValue: an extended cell specification which has the coordinates of the 2x2, followed by the maximum value in the quad
  unique (optional): If True, only one cell can equal the maximum. Defaults to False.
  
setQuadMaxValueArray(list,unique): set multiple Quad Max value constraints
  list: list of extended cell specifications per setQuadMaxValue method
  unique (optional): If True, only one cell can equal the maximum. Defaults to False.
  
setQuadMinValue(cellValue,unique): constraint on a 2x2 indicating the minimum value in the quad
  cellValue: an extended cell specification which has the coordinates of the 2x2, followed by the minimum value in the quad
  unique (optional): If True, only one cell can equal the maximum. Defaults to False.
  
setQuadMinValueArray(list,unique): set multiple Quad Min value constraints
  list: list of extended cell specifications per setQuadMinValue method
  unique (optional): If True, only one cell can equal the maximum. Defaults to False.
  
setQuadMaxParity(cellValue): constraint on a 2x2 indicating the parity of the maximum value in the quad
  cellValue: an extended cell specification which has the coordinates of the 2x2, followed by the parity of the maximum value in the quad; can use 0 for odd and 1 for even in shorthand notation, or the Even/Odd class variables
  
setQuadMaxParityArray(list): set multiple Quad Max parity constraints
  list: list of extended cell specifications per setQuadMaxParity method
  
setQuadMinParity(cellValue): same as QuadMaxParity, but for minima
  
setQuadMinParityArray(list): same as QuadMaxParityArray, but for minima
  
setQuadMaxParityValue(row,col,values,unique): 2x2 constraint indicating the largest value *of its parity* appearing in the quad
  row,col: the coordinates of the quad being clued
  values: a list of up to two values (one of each parity) which are specified as the maxima
  unique: Optional, if True, forces the maximum parity value to be unique. Default is True.
  Note: If using the default unique=True, the argument can be specified in shorthand without punctuation, e.g., 1234, meaning quad 1,2 has max odd 3 and max even 4.
  
setQuadMinParityValue(row,col,values,unique): 2x2 constraint indicating the smallest value *of its parity* appearing in the quad
  row,col: the coordinates of the quad being clued
  values: a list of up to two values (one of each parity) which are specified as the minima
  unique: Optional, if True, forces the minimum parity value to be unique. Default is True.
  Note: If using the default unique=True, the argument can be specified in shorthand without punctuation, e.g., 1234, meaning quad 1,2 has min odd 3 and min even 4.

Quad Sums
---------
setQuadSum(cell): assert that one of the digits in a quad is the sum of the other 3
  cell: single cell specification
  
setQuadSumArray(list): set multiple quad sum constraints
  list: list of cell specifications

QuattroQuadri
-------------
To model a QuattroQuadri, you must use the class quattroQuadri, e.g.

from quattroQuadri import quattroQuadri
p = quattroQuadri(boardSizeRoot,gridSize,irregular,digitSet)
	Assuming standard square regions, boardSizeRoot is the number of rows/columns in each region, and grid size is number of regions in each row/column of the grid. So a standard QuattroQuadri would have boardSizeRoot = 3 and gridSize = 2. These are the defaults, and need not be given in the declaration.
	
	irregular allows the possibility of setting irregular regions. Set to True and use the setRegion method to define regions. Default is False.
	
	digitSet is the set of digits allowed. Default is {1,2,3,4,5,6,7,8,9}.
	
	So a standard QuattroQuadri puzzle can be defined via p = quattroQuadri(), with no options set.

Region Sum Lines
----------------
See Irregular Sudoku's setRegion method to set regions that affect Region Sum Lines. By default regions are the boxes in normal Sudoku rules.
setRegionSumLine(list): asserts that the sum of all cells on the line in each region is fixed across regions, regardless of contiguity along the line
  list: list of cell specifications
  
setRegionSegmentSumLine(list): asserts that the sum of cells on line in each visit to a region is fixed, with discontiguous segments in a region counted as different visits
  list: list of cell specifications
  
Remote Clone Cell
-----------------
setRemoteCloneCell(row,col,dir1,dir2): if N is the digit in the cell, then the cell N cells away in dir1 and the cell N cells away in dir2 are equal
  row,col: cell specification
  dir1,dir2: directions; use class variables Up, Down, Left, Right
  Shorthand is available, can be clued 2413, which would be a clue in cell 24, pointing Down and Right; Up = 0, Down = 1, Left = 2, Right = 3

Renban Lines
------------
setRenbanLine(list): set a Renban line constraint
  list: list of cell specifications
  
setRunOnRenbanLine(list,n): set a run-on Renban line, i.e. a line where each contiguous subsegment of length n is a Renban line
  list: list of cell specifications
  n: length of subsegment that is a Renban. If not present, defaults to 5
  
setRenrenbanbanLine(list): line consists of two renban sets, whose digits may overlap
	list: list of cell specifications
NOTE: do not use with countSolutions...has unconstrained Booleans that will give multiple solutions for each set of digits
  
setNotRenbanLine(list): asserts that a set of digits does NOT form a Renban line
  list: list of cell specifications
  
Repeated Neighbors
------------------
setRepeatedNeighbors(cell): asserts that at least two of this cells orthogonal neighbors must have the same digit
  cell: cell specification
  
setRepeatedNeighborsArray(list): set multiple repeated neighbors constraints
  list: list of cell specifications

setDistinctNeighbors(cell): asserts that all digits in this cell's orthogonal neighbors are distinct
  cell: cell specification
  
setDistinctNeighborsArray(list): set multiple distinct neighbors constraints
  list: list of cell specifications
  
setRepeatedNeighborsNegative(): asserts the negative constraint, that only cells specifically marked as having
  repeated neighbors do so

Repelling Digits
----------------
setRepellingDigit(value,list): assert that no cell containing digit value can be orthogonally adjacent to a cell containing a digit from list
  value: the value of the repelling digit
  list: list of digits that value repels

Roping
------
assertNoRoping(rc): assert that there is no roping (three values appearing together in a row/column in all three boxes across or down
  rc: row/column specification, use class variables Row and Col

Rossini Clues
-------------
Rossini clues appear as arrows on the outside of of the grid, and indicate that the first few cells next to the clue increase in the given direction. In normal Sudoku there is no ambiguity, since the number of cells used is 3, but is that 3 because of the region, or because 3 is a nice number? We provide the option to define the length of the run applied either by using regions, or specifying a value.

setRossini(row,col,uldr): sets a Rossini constraint on a row or column
  row,col: The coordinates of the cell next to which the clue values sit
  uldr: Determines if the arrow points Top/Bottom (for columns) or Left/Right (for rows)...use class variables Up, Down, Left, and Right
  By default, Rossini conditions operate on regions
  
setRossiniLength(value): changes cluing behavior to work on a fixed number of cells from the border
	value: number of cells to test for increase/decrease
	
setRossiniNegative(): assert a negative constraint on the Rossini conditions, i.e. rows/columns without clues do not strictly increase/decrease in the Rossini window

Row/Column Region Sums
----------------------
setRCRegionSum(row,col,rc,value): Asserts that the sum of the cells in the intersection of the clued row/column with some region equals value
  row,col: The coordinates of the cell next to which the clue values sit
  rc: row/column specification, use class variables Row and Col
  value: the sum of the values in the row/column in some region

Samurai Sudoku
--------------
To model a Samurai Sudoku puzzle, you must use the class samuraiSudoku, e.g.

from multiSudoku import samuraiSudoku
p = samuraiSudoku(boardSizeRoot)

The 5 sub-Sudoku puzzles are labelled
1 2
 3
4 5

In this class, you can use the following method:
setSamuraiConstraint(puzzle,constraint,argsd): sets a Samurai constraint
	puzzle: the puzzle number (1-5) to which the constraint should apply
	constraint: a string containing the name of the constraint (e.g. 'GivenArray')..do not include the 'set' used in the method name
	args: the arguments that you wish to pass to the constraint, just as if you were passing them with the normal 'set' method

Sandwich Sums
-------------
setSandwichSum(row,col,rc,value,digits): sets a sandwich sum constraint
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the values between the 1 and 9 in the clued row/column
  digits (optional): A list of two digits to form the "bread" of the sandwich. Defaults to the minimum and maximum digit.
  
setOpenfacedSandwichSum(row,col,rc,value,digit): set an open-face sandwich sum clue, i.e. the sum of all digits in the row/col up to a bread digit
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the values before the sandwich digit in the clued row/column
  digit (optional): The sandwich digit. Optional, defaults to 9.
  
setBeforeNine(row,col,rc,value): an alias for Openfaced sandwich sums, with sandwich digit 9

setConditionalSandwichSum(row,col,value,digits,selectCriteria): set a sandwich clue where only some cells in the sandwich may contribute to the sum
  row,col,rc,value,digits are all as in setSandwichSum
  selectCriteria: a list of selection criteria, as defined in setHangingSum, that defines which digits are included in the sum

Another option for sandwiches is to have specially designated "crust cells", subject to topological conditions (typically two per row/column/box) where
sandwich sum is defined as being between the two crusts. Crust sandwich requires use of a different class, like so:

from crustSandwichSudoku import crustSandwichSudoku
p = crustSandwichSudoku(boardSizeRoot,enforceRegions=False,includeCrust=False,selectCriteria=[['All']])
  Each row and column must have exactly two crust cells. By default, each region(box) will have two crust cells as well, but this restriction 
  can be relaxed by setting enforceRegions to False. As in regular sandwich rules, the sandwich sum by default does not include the crust digits,
  but this can also be relaxed by setting includeCrust to True. This class also inherits the irregular and digitSet parameters, which may be used
  to define irregular regions and alternate digit sets. It might even work.
  
To set a crust sandwich clue, the normal setSandwichSum call as above can be used, and it will be applied with the selectCriteria defined in initialization, if any. There are additional methods:
  setCrustHasLength(): asserts that one of the crust digits must equal the number of cells in the sandwich for each sandwich
  
  setTwoCrustDigits(): asserts that the pair of crust digits are the same for each row/column
  
  setCrustStarBattle(): asserts that the crust digits must satisfy Star Battle constraints, i.e. no two crust digits can be adjacent either orthogonally or diagonally. Enforcing the additional constraint that there are two crust cells per region can be done with the "enforceRegions" parameter to the puzzle initiation.

  setXDistanceCrust(row,col,rc): the distance between the two crust cells is given by the first cell in the grid next to the clue
    row,col: the coordinates of the cell
    rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables

  setXDistanceCrustNegative(row,col,rc): the distance between the two crust cells is *not* given by the first cell in the grid next to the clue
    row,col: the coordinates of the cell
    rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables

  setCrustSum(row,col,rc,value): constrains the sum of the values of the crust cells in row/column to be value
    row,col: the coordinates of the cell
    rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
    value: sum of the crust cells

  setCrustInstance(row,col,rc,values): forces the digits in values to be crust digits in the clued row/column
    row,col: the coordinates of the cell
    rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
    values: a list of 1 or 2 digits which must appear as crust digits in the row/column
  
Scary Cells
-----------
setScary(row,col,diff): set a scary cell, i.e. a cell all of whose neighbors (orthogonal and diagonal) differ from it by at least diff
  row,col: the coordinates of the cell
  diff: Optional, default = 3...sets the difference required for neighboring cells of a scary cell
  
There is a grid-wide version of scary cells that asserts there is a scary cell in each row, column and region. Use:
from scarySudoku import scarySudoku
p = scarySudoku()
The arguments to this constructor are the same as for sudoku, except for the additional parameters:
  diff: Optional, default = 3, sets the difference between scary cells and their neighbors
  noDiag: Optional, default is False, asserts there are no scary cells on the same diagonal (anti-queen)
  allDifferent: Optional, default is False, asserts that the digits in scary cells are all different

Schr√∂dinger Cell Sudoku
-----------------------
Allows creation of puzzles with Schr√∂dinger cells. An additional digit (usually 0) is added, and one cell in each row, column and region is a Schr√∂dinger cell, which has two values. When used in constraints, it is considered to contain both values. Not all constraints work with Schr√∂dinger cells, and most have multiple interpretations. They are detailed below.

To model a Schr√∂dinger Cell Sudoku puzzle, you must use the class schroedingerCellSudoku, e.g.

from schroedingerSudoku import schroedingerCellSudoku
p = schroedingerCellSudoku(boardSizeRoot)

  Note: the conventions around how S-cells interact with constraints are not standardized, so this attempts to be flexible. Particular issues:
  1. Constraints such as extra regions and X sudoku normally elide the difference about whether all the digits in the area are the same, or whether all digits appear; these are equivalent in normal Sudoku. Here, the default behavior is to assume all digits appear, which forces an S-cell. However, by setting the "allDigits=False" flag in some some method calls, this behavior can be suppressed, and these constraints will only enforce that all digits are different.
  2. Constraints which use addition are fairly consistent that, when used as a summand, both digits of an S-cell should be added to the total. However, with conditions such as arrow clues, it is not obvious what to do if the target sum is an S-cell. By default, this code assumes that such a target sum CANNOT be an S-cell, since the sum assertion cannot possibly be true for both values. However, some puzzles assert that the sum of the Schr√∂dinger cell digits should be the target sum, and this behavior is support with the "sSum=True" flag.

  Implemented Constraints
  -----------------------
  Anti-king
  Anti-knight
  Arrows (including Double Arrows)
  Between lines - all digits on the line must be less than all digits on one end point and greater than all digits on the other end poit
  Block Cages
  Disjoint Groups - allDigits=False can be applied, forcing all 10 digits to appear in each location
  Even/Odd
  Given digits - setting a given digits enforces the corresponding cell is not a Schr√∂dinger cell
  Killer cages
  Kropki - if either cell is Schr√∂dinger, both digits have to have the specified relationship with the counterpart
  Min/max cells - the less than/greater than comparisons are made against both values
  Neighbor Sum - sSum=True can be applied
  Nonconsecutive
  Numbered Rooms - code assumes index cell cannot be Schr√∂dinger
  Parity Lines
  Region Sum Lines
  Renban Lines
  Thermos/Slow Thermos
  Unicorn Digits
  Vaults
  Whispers Lines - sSum=True can be applied; normally both digits in an S-cell on a whispers line must meet the whispers criteria, with sSum=True, the sum of the digits in an sCell must meet the criterion. To use sSum=True, the base minWhispers/maxWhispers lines functions must be used, not the nationality whispers aliases
  Windoku - allDigits=False can be applied
  X/Diagonal Sudoku - allDigits=False can be applied
  XV
  XVXV
  X-Sums - sSum=True can be applied to toggle whether S-cell sum is applied to indexing clue

  Schr√∂dinger Specific Concerns
  ----------------------------
  When specifying given digits with setGiven and setGivenArray, the syntax to indicate the definition is extended. If specified with 3 digits only, e.g. 145, setGiven will set the indicated cell (14) equal to the given value (5), and asserts it is NOT a Schr√∂dinger cell. If specified with 4 digits, the behaviors depends on whether the two given digits are equal or not. If they are not equal, then setGiven will set both values in the cell, and designate it a Schr√∂dinger cell. If these two given digits are equal, setGiven does assert that value is in the cell, but leaves it ambiguous whether or not that cell is a Schr√∂dinger cell.
  
  There are some additional methods with Schr√∂dinger cells:
  
  setIsSCell(cell): asserts that the indicated cell is a Schr√∂dinger cell
    cell: rowcol or (row,col) cell specification
	
  setIsSCellArray(list): set a list of cell specifications to be Schr√∂dinger cells
  
  setIsNotSCell(cell): asserts the indicated cell is not a Schr√∂dinger cell
    cell: rowcol or (row,col) cell specification
	
  setIsNotSCellArray(list): set a list of cell specifications to not be Schr√∂dinger cells
  
  setSchroedingerAntiKing(): asserts that no two Schr√∂dinger cells are a king's move from each other, i.e. not diagonally adjacent

There is an alternative class for Schr√∂dinger sudoku, called superpositionSudoku. In this instance, the constraints are defined to be more akin to classic superposition, where either value can be used, and thus the values are never added or averaged. Each independently needs to be able to satisfy the constraint, perhaps with help from other S-cells. So for example, an arrow constraint with bulb 5/7 and arrow cells 2 and 3/5 would be legal, since 5,2,3 is a valid solution, as is 7,2,5. For another example, a Renban line could be 48,5,6,7, since either the 4 or 8 could pair with the other three digits, but 45,6,7,8 is not legal, since 4,6,7,8 is not a set of consecutive digits. On the gripping hand, 38,47,5,6 IS a legal renban assignment, since 3456 is legal, and 8756 is also legal. So not every combination of S-cell values needs to be legal, just at least one legal assignment for each value in each S-cell.

This class is under development, and the only safe constraints to use at this point are:
  Anti-king
  Anti-knight
  Arrows (including Double Arrows)
  Between lines
  Block Cages
  Disjoint Groups
  Even/Odd
  Given digits
  Min/max cells
  Parity Lines
  Renban Lines
  Thermos/Slow Thermos
  Unicorn Digits
  Vaults
  X/Diagonal Sudoku

Search Nine
-----------
setSearchNine(row,col,uldr,digit): Arrow gives direction, cell value a distance to a cell with value digit.
  row,col: The coordinates of the cell in which the clue values sit
  uldr: Determines if the arrow points Up/Down/Left/Right...use class variables Up, Down, Left, and Right
  digit: The value of the digit pointed to; optional, defaults to 9. Note: digit can be a *list*, if an arrow must point to one of several possible digits.
  
Sequence Lines
--------------
setSequenceLine(inlist): digits on a sequence line form an arithmetic sequence (same difference) from one end to the other
  inlist: list of cell specifications

Shift Lines
-----------
setShiftLine(inlist): sets a shift line constraint; like a palindrome, but one side is uniformly one larger than the other
  inlist: list of cell specifications

Skyscrapers
-----------
setSkyscraper(row,col,rc,value,depth): sets a skyscraper constraint, specifying the number of digits that can be "seen" from the clue, where seen means greater than all digits between it and the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the number of digits that can be seen
  depth (optional): only skyscrapers at most <depth> cells from the puzzle edge can be seen. Defaults to whole board.
  
setSkyscraperSum(row,col,rc,value,depth): sets a skyscraper sum constraint, specifying the SUM OF the number of digits that can be "seen" from the clue, where seen means greater than all digits between it and the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the sum of digits that can be seen
  depth (optional): only skyscrapers at most <depth> cells from the puzzle edge can be seen. Defaults to whole board.
  
Slingshots
----------
setSlingshot(row,col,tail,head): assert that the digit pointed to by tail from (row,col) is equal to a cell pointed at by head, where the distance to this second occurrence is the digit in the cell (row,col)
  row,col: The coordinates of the cell in which the slingshot arrow lies
  tail: the direction in which the tail of the arrow points; use class variables Up, Down, Left, Right
  head: the direction in which the head of the arrow points; use class variables Up, Down, Left, Right

Slot Machine
------------
setSlotMachine(list): each column in the list has the exact same ordering of digits, when read around bottom to top
  list: list of column numbers, default is 2,5,8

Split Pea Lines
---------------
setSplitPeaLine(inlist): the sum of the interior cells on the line is equal to some concatenation of the first digit and last digit of the line, where either may be the tens digit
  inlist: list of cell specifications

Star Battle Sudoku
------------------
Solver code for sudoku/star battle hybrid puzzles. To model a Star Battle Sudoku puzzle, you must use the class starBattleSudoku, e.g.

from starBattleSudoku import starBattleSudoku
p = starBattleSudoku(3,digitList=[1,2,3,4,5,6,7,8,9])

The parameters listed above are required: the first is positional and defines the size of the grid as being a 9x9. 4 would give 16x6, etc.
The digit list is a list of the digits that must appear in each row/column/region of the solved grid. Note that this list may have repeats.
  A typical use case would be to denote 0 as a star, and have the digit list be [1,2,3,4,5,6,7,0,0], where each row/column/region will have 
  each of the digits 1-7 appearing once, and two "stars", indicated by 0. Indeed, this is the default digit list.
  
A star battle sudoku grid can be irregular: use the parameter irregular = True, and then define the regions manually with setRegion.
  
There is no single standard of how to integrate star battle in with sudoku, so this code attempts to be as flexible as possible to cover
the use cases I've seen. To do this, there are two additional parameters which can be used to control the star battle integration:

  starSymbols - a list of digits from digit list which act like stars (i.e., none are neighbors, even diagonally, and counts are enforced)
  numberOfStars - the number of star cells in each row/column/region; the symbols in starSymbols will be used, but other digits may be designated stars to ensure the number is correct
  
Both parameters are optional, though if neither is given results will be basically unconstrained.

The use cases these parameters cover:
a. There is a limited set of digits, and specific star symbols which are not sudoku digits (even though they are represented as digits in the computer). In this case, a row may consist of the digits from 1-7 and two stars. The puzzle constructor would look like:
  p = starBattleSudoku(3,digitList=[1,2,3,4,5,6,7,0,0],starSymbols=[0])
  
b. All digits are sudoku digits, but some subset of specified digits are also treated as "stars", subject to the star battle constraint. The call would be:
  p = starBattleSudoku(3,digitList=[1,2,3,4,5,6,7,8,9],starSymbols=[1,9])
  
c. All digits are sudoku digits, and some to-be-determined digits are treated as stars.
  p = starBattleSudoku(3,digitList=[1,2,3,4,5,6,7,8,9],numberOfStars=2)

d. A hybrid is possible. The call
  p = starBattleSudoku(3,digitList=[1,2,3,4,5,6,7,8,9],starSymbols=[1],numberOfStars=2)
would create a puzzle where 1 and some other to-be-determined digit act as stars.

Note: this solver could also be used as a straight star battle solver by setting the digit set to be [0...0,1...1], where 0s are stars and 1s are not stars. But it is restricted to sqaure grids. I should probably work on that some day. But not today.

Sum Sandwiches
--------------
setSumSandwich(row,col,rc,values,neg=False): sets a sum sandwich - in a row/column, each value in values is the sum of its neighbors, e.g., the 9 in that row/column must be between two digits that sum to 9
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: a list of values who are the "filling" in a sum sandwich in the designated row/column
  neg: Optional, default False. Asserts that digits not in the value list are *not* the sum of their neighbors
  
Sweepers
--------
setSweeper(row,col,selectSummands,includeSelf=True,orthogonalOnly=False): Defines cell to be a sweeper cell, whose value is the number of neighboring cells which satisfy the the defined selection criteria
  row,col: Coordinates of the sweeper cell
  selectSummands: See Hanging Sums for description of available selection criteria to pick "matching" cells.
    ***!!!NOTE!!!***: When giving selection criteria that match the sweeper cell, use position 1.
  includeSelf: Default is True; if True, cell itself counts as one of its neighbors.
  orthogonalOnly: Default is False; if True, only neighbors sharing an edge with the sweeper cell are counted. If False, all orthogonal and diagonal neighbors are counted.
  
setAntiSweeper(row,col,selectSummands,includeSelf=True,orthogonalOnly=False): Defines cell to not be a sweeper cell

setSweeperNegative(selectSummands,includeSelf=True,orthogonalOnly=False): Asserts that all cells not specifically designated as sweeper cells will not be sweeper cells.

Thermometers
------------
setThermo(list,slow,missing,speed,broken,brokenThreshold,brokenMinDrop): asserts that the values in cells increase from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  slow (optional): set thermo to slow (i.e., nondecreasing vs. increasing); Optional: defaults to False, can also use setSlowThermo
  missing (optional): set thermo to have missing bulb, so increase may start from either end; Optional: defaults to False, can also use setMissingThermo.
  speed (optional): provides several options about the speed of the thermo, i.e., the level of difference between consecutive values.      
    Allowable values are:
    'slow': Same as setting slow=True
	'fast': Ensures that each value along a fast thermo is at least two larger than the previous cell, can also use setFastThermo
	integer: Each value along a thermo is strictly greater than the previous value plus the speed. So speed=1 is equivalent to speed='fast'
  broken (optional): set thermo to allow breaks when passing between regions, if value of last cell of thermo in region is at least brokenThreshold. First cell in next region must be at least brokenMinDrop less. Defaults to False. See also setBrokenThermo.
  brokenThreshold (optional): sets threshold at which thermo can break. Defaults to largest allowable digit, typically 9.
  brokenMinDrop (optional): sets minimum amount by which value has to drop across a break. Defaults to threshold - smallest allowable digit, i.e., by default we must go to the minimum digit. typically 1.
  
setSlowThermo(list,missing): asserts that the values in cells do not decrease from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  missing: Optional, defaults to false. See setThermo
 
setFastThermo(list,missing): asserts that the values in cells increase by at least 2 from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  missing: Optional, defaults to false. See setThermo
  
setOddEvenThermo(list,slow,missing): asserts that the values in cells increase from the beginning of the line to the end, and all have the same parity
  list: list of cell specifications, with bulb end of thermo being the first element
  slow: set thermo to slow (i.e., nondecreasing vs. increasing), defaults to False, can also use setSlowOddEvenThermo
  missing: set thermo to have missing bulb, so increase may start from either end; Optional: defaults to False.
  
setSlowOddEvenThermo(list): asserts that the values in cells do not decrease from the beginning of the line to the end, and all have the same parity
  list: list of cell specifications, with bulb end of thermo being the first element
  
setMissingThermo(list,slow): asserts that the values increase from one end of the thermo to the other, but which end is which is not determined
  list: list of cell specifications
  slow: set thermo to slow (i.e., nondecreasing vs. increasing); Optional: defaults to False
  
setBrokenThermo(list,brokenThreshold,brokenMinDrop): sets broken thermo constraint. See setThermo for details on parameters.
  
setRemovedBulbThermo(list,slow): a thermo on which the bulb may appear anywhere, forming one or two thermos 
  list: list of cell specifications
  slow: may set thermos to slow, default is False
  
setDoubleThermo(list,slow,missing,increaseCriteria): sets a thermo where even and odd numbers are treated independently
  list: list of cell specifications, first cell is bulb end unless missing is True
  slow (optional): Default is False. Thermos are slow, i.e. nondecreasing instead of strictly increasing
  missing (optional): Default is False. Either end of the line may be the bulb.
  increaseCriteria (optional): Default is 'Both'. Determines how the different parities act. Options are:
    'Both': While they may be interleaved, the odd digits and even digits each form a thermo in the same direction
	'Even': The even digits form a thermo, the odd digits have no constraint
	'Odd': The odd digits form a thermo, the even digits have no constraint
	'First': Cells with the same parity as the first cell form a thermo, the other parity has no constraint. If paired with the missing option, the "first" cell may appear at either end.
	'BothMissing': OK, this was a weird corner case that took up a lot of code, but it's *cool*. In the case of missing thermos, the default 'Both' option will order the evens and odds in thermos, but both thermos will increase in the same direction. This option allows (but does not force) the even and odd thermos to start at different ends of the missing thermo.
	'MissingOpposite': Like BothMissing, but the odds and evens are forced to start at different ends of the missing thermo.
  
Triple Tabs
-----------
setTripleTab(row,col,uldr,digits,cellCount): sets a triple tab clue, which is like an Outside clue, but appears inside the grid and is based at a cell
	row,col: the cell where the clue is placed
	uldr: defines the direction the clue points from the base cell. Use class variables Up, Down, Left, Right
	digits: a list of digits that must appear in the direction pointed by the tab
	cellCount: the number of cells from the base cell in which the given digits must appear (Default: 3)

Unicorn Digits
--------------
setUnicornDigit(value): set a unicorn digit, i.e. for any instance of that digit in the grid, all of the cells a knight's move away have distinct values
	value: value of the digit to be a unicorn

Up and Down Lines
-----------------
setUpAndDownLine(inlist): sets an up and down line constraint; cells must alternately increase and decrease
  inlist: list of cell specifications
  
Unique Pairs Lines
------------------
setUniquePairsLines(inlist): creates a set of lines such that each line has no repeats, and no pair of lines in the set have more than one digit in common
  inlist: list of lists of cell specifications, so a list of lines

Weak Palindrome Lines
---------------------
setWeakPalindromeLine(list): creates a weak palindrome line constraint: instead of matching digits, palindromic positions must match on parity and magnitude (1-4 vs. 5-9)
  list: a list of cell specifications
  
Whispers Lines
--------------
setMinWhispersLine(inlist,value): asserts two adjacent cells on a line have a difference of at least value
	inlist: list of cell specifications
	value: integer

setMaxWhispersLine(inlist,value): asserts two adjacent cells on a line have a difference of at most value
	inlist: list of cell specifications
	value: integer
	
setChineseWhispersLine(inlist): two adjacent cells on a line have a difference of at most 2
	inlist: list of cell specifications
	
setDutchWhispersLine(inlist): two adjacent cells on a line have a difference of at least 4
	inlist: list of cell specifications
	
setGermanWhispersLine(inlist): two adjacent cells on a line have a difference of at least 5
	inlist: list of cell specifications

Windoku
-------
setWindoku(): assert Windoku rules

X-Distance
----------
setXDistance(row,col,rc,value1,value2): In the row/column, value1 appears before value2, and the distance between them is the digit in the first cell in the row/column
  row,col: coordinates of the cell next to the clue
  rc: indicates whether rule applies to row or column. Use Row and Col class variables
  value1: first digit to appear
  value2: second digit to appear

X-Kropki
--------
setXKropki(row,col,rc,wb,neg): The first cell next to the Kropki dot (outside the grid) indicates the position (0-7) of the corresponding Kropki dot in the row/column. Designed by Zegres.
  row,col: coordinates of the cell next to the clue
  rc: indicates whether rule applies to row or column. Use Row and Col class variables
  wb: indicates whether Kropki clue is white or black. Use White and Black class variables
  neg (optional, default False): If true, indicates that there are no other Kropki relationships of the same color in the row/column
  
XSudoku
-------
setXSudokuMain(): assert no repeats on the main (top left to bottom right) diagonal

setXSudokuOff(): assert no repeats on the off (top right to bottom left) diagonal

setBentDiagonals(): assert no repeats on the bent diagonals between adjacent corners through the center box

setAntiDiagonalMain(): assert that the main diagonal contains the minimum number of digits possible (3 for normal sudoku)

setAntiDiagonalOff(): assert that the off diagonal contains the minimum number of digits possible (3 for normal sudoku)

X-Outside
---------
setXOutside(row,col,rc,values): assert that all of the digits in values must appear in the first X cells of the clued row/column, where X is the digit in the cell next to the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: List of digits to appear

X-Sum
-----
setXSum(row,col,rc,value,depth,depthStyle,broken): set an X sum constraint on a row or column
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells in the row/column from the clue, where X is the value in the adjacent cell
  Note: for negative digits, the behavior of an X-Sum is to take digits from the other side of the row/column, a la a reverse sum
  depth (Optional): depth=1 is the default, which acts like a normal X-Sums clue. If depth is greater than 1, then the cell which picks the length of the sum can be anywhere in the first "depth" cells of the clued row/column. If depth is 0, then the cell which picks the length of the sum can be anywhere where the clued row/column meets the region containing the cell next to the clue.
  depthStyle (Optional): By default, any cell allowed to have the length picker by depth can contain it. depthStyle can be set to 'Smallest' or 'Largest' to force the smallest or largest value in the set of possible cells to be the one chosen.
  broken (Optional): If True, the length of the sum is either +1 or -1 from a length picker. False by default.
  
setReverseXSum(row,col,rc,value,depth,depthStyle,broken): set a reverse X sum constraint on a row or column, where the sum is taken on cells starting from the end of the row/column opposite the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells on the other side of the row/column from the clue, where X is the value in the adjacent cell
  Note: for negative digits, the behavior of a Reverse X-Sum is to take digits from the other side of the row/column, a la regular X-Sum
  depth (Optional): depth=1 is the default, which acts like a normal X-Sums clue. If depth is greater than 1, then the cell which picks the length of the sum can be anywhere in the first "depth" cells of the clued row/column. If depth is 0, then the cell which picks the length of the sum can be anywhere where the clued row/column meets the region containing the cell next to the clue.
  depthStyle (Optional): By default, any cell allowed to have the length picker by depth can contain it. depthStyle can be set to 'Smallest' or 'Largest' to force the smallest or largest value in the set of possible cells to be the one chosen.
  broken (Optional): If True, the length of the sum is either +1 or -1 from a length picker. False by default.
  
setDoubleXSum(row,col,rc,value): set a double X sum constraint on a row or column, where the clue is the sum of the X sums taken from both sides of the row/column
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells in the row/column from the clue, where X is the value in the adjacent cell, plus the sum of the first Y cells in the row/column on the other side of the row/column from the clue, where Y is the value in the cell furthest from the clue.
  Note: for negative digits, the behavior of either of the sums in a double sum is exactly as in X-sums, to take the sum from the other side
  
setXAverage(row,col,rc,value): like an X Sum, but specifies the average of the cells

setReverseXAverage(row,col,rc,value): like a reverse X Sum, but specifies the average of the cells
  
XV/XV Pairs
-----------
setXVV(cellHV): creates a V clue
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a V clue on the bottom edge of cell 2,5
  
setXVX(cellHV): creates an X clue
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify an X clue on the bottom edge of cell 2,5

setXVVArray(list): creates multiple V clues
  list: list of cellHV specifications, see setXVV

setXVXArray(list): creates multiple X clues
  list: list of cellHV specifications, see setXVX
  
setXVArray(list): creates multiple X/V clues
  list: list of cellHVXV specifications, which include a cell spec, the HV spec as given in setXVV, and a XV spec, specifying the type of clue. When given as a tuple, the X and V variables can be used to specify X/V clues. Shorthand is possible, with V being 0 and X 1.
  Example: 1701 incidates an X (1 XV spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.X)
  
setAntiXVV(cellHV): asserts that a pair of cells cannot add to 5
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V.

setAntiXVX(cellHV): asserts that a pair of cells cannot add to 10
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
	
setAntiXV(cellHV): asserts that a pair of cells cannot add to either 5 or 10
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 

setAntiXVVArray(list): creates multiple anti-V clues
  list: list of cellHV specifications

setAntiXVXArray(list): creates multiple anti-X clues
  list: list of cellHV specifications

setAntiXVArray(list): creates multiple anti-XV clues
  list: list of cellHV specifications

setXVVNegative(dominoesOnly): implements negative constraint, all pairs not marked with another Roman numeral cannot sum to 5

setXVXNegative(dominoesOnly): implements negative constraint, all pairs not marked with another Roman numeral cannot sum to 10

setXVNegative(dominoesOnly): implements negative constraint, all pairs not marked with another Roman numeral cannot sum to 5 or 10
  dominoesOnly is an optional parameter, defaulting to False, which sets the negative constraint only on pairs of adjacent cells such that neither cell lies on a positive clue...if one thinks of the pairs as dominoes, no additional non-overlapping dominoes can be placed

Roman sums are similar to XV, but can use any set of numbers.

setRomanSum(cellHV#): creates a "Roman numeral"-clue for an arbitrary value
  cellHV#: an extended cell specification which adds the hv parameter and value parameters.

setRomanSumArray(list): create multiple Roman sum clues
  list: list of cellHV# specifications, see setRomanSum

setAntiRomanSum(cellHV#): creates a negative assertion of a specific sum value, so that the sum may NOT equal that value
  cellHV#: see above
  
setAntiRomanSumArray(list): create multiple setAntiRomanSum constraints
  list: list of cellHV# specifications

setAntiRomanSums(cellHV): creates a negative assertion that the sum of the clued cells cannot be any number already used in a Roman Sum clue, or specified in the negative constraint (see below)
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 

setAntiRomanSumsArray(list): create multiple setAntiRomanSums constraints
  list: list of cellHV specifications
  
setRomanSumNegative(list,dominoesOnly): implements negative constraint, all pairs not marked with a Roman numeral can sum to any value used in a clue, or to any additional value provided in list
  list: list of forbidden sum values
  dominoesOnly is an optional parameter, defaulting to False, which sets the negative constraint only on pairs of adjacent cells such that neither cell lies on a positive clue...if one thinks of the pairs as dominoes, no additional non-overlapping dominoes can be placed

XVXV
----
setXVXVV(cellHV): creates a V clue, in XVXV rules, where sum may be 5 or 15
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a V clue on the bottom edge of cell 2,5
  
setXVXVX(cellHV): creates an X clue, in XVXV rules, where sum may be 10 or 15
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify an X clue on the bottom edge of cell 2,5
  
setXVXVVArray(list): creates multiple V clues
  list: list of cellHV specifications, see setXVV

setXVXVXArray(list): creates multiple X clues
  list: list of cellHV specifications, see setXVX
  
setXVXVArray(list): creates multiple X/V clues
  list: list of cellHVXV specifications, which include a cell spec, the HV spec as given in setXVV, and a XV spec, specifying the type of clue. When given as a tuple, the X and V variables can be used to specify X/V clues. Shorthand is possible, with V being 0 and X 1.
  Example: 1701 incidates an X (1 XV spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.X)
  
setAntiXVXV(cellHV): asserts that a pair of cells cannot add to either 5 or 10 or 15
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXVXVArray(list): creates multiple anti-XVXV clues
  list: list of cellHV specifications, see setXVXVV
  
setXVXVNegative(): implements negative constraint

Vaults
------
setVault(list): sets a vault, i.e., a region sich that no cell inside the region can appear in any cell outside, but orthogonally adjacent to any cell of the region
  list: list of cell specifications

XY-Difference Pairs
-------------------
setXYDifference(cellHV): creates an XY-difference clue, where the difference of the two cells separated by the clue equals the first cell in the row/column
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a XY-difference clue on the bottom edge of cell 2,5

setAntiXYDifference(cellHV): asserts that a pair of cells cannot have difference equal to the first cell in the row/column
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXYDifferenceArray(list): creates multiple anti-XY Difference clues
  list: list of cellHV specifications, see setXYDifference
  
setXYDifferenceNegative(): implements negative constraint

Zipper Lines
------------
setZipperLine(list): for an odd length, the sum of the cells equidistant from the ends equals the cell in the middle of the line. For an even length line, the sum of the cells equidistant from the ends is constant
  list: list of cell specifications

Zones
-----
setZone(list,values,nulls): sets a zone, i.e., a set of cells and a list of values such that each value must appear in the zone, *including repeats*
  list: list of cell specifications
  values: list of values to appear in the zone, which may include repeats
  nulls: a set of digits which may not appear in the zone.
  
setLookAndSayCage(list,string): sets a look-and-say cage, where the string is the cage clue as written. So, "0123" will ensure the cage includes no 1s and exactly two threes
  list: list of cell specifications
  string: string of integers describing cell contents. Must be even length.
  
setPsychoLookAndSayCage(list,string): elements of the cage *provide a reference* to the digit in the same relative position in the box indicated by the cage element. The look-and-say string provides a verbal description of the contents of the referred cells.
  list: list of cell specifications of cells in the cage
  string: string of integers describing referred cell contents. Must be even length.