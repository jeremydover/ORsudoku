Supported Constraint List
=========================
10 Lines
159 (see Indexing)
All Odd or Even
Alternate Digits
Anti-Diagonal - see XSudoku
Anti-King
Anti-Knight
Anti-Queen
Arrows
Ascending Starters
Average Lines
Battenburg
Battlefield
Before Nine - see Sandwich Sums
Bent Diagonals - see XSudoku
Between Lines
Block Cages
Capsules
Cell Transform Sudoku
Chinese Whispers Lines - see Whispers Lines
Clock Lines
Clone Regions
Close Neighbors - see Global Whispers
Consecutive Chain Regions
Consecutive Lines
Consecutive Quads
Corner/Edge Clues
Count the Odds Lines
Counting Circles
Cupid Clues
David and Goliath Pairs
Descriptive Pairs
Diagonal Consecutive Pairs
Diagonal Mirrors
Difference Pairs - see Kropki and Kropki Pairs
Different Neighbors
Digit Count Cages
Disjoint Groups
Dominant Clone Regions - see Clone Regions
Double Arrows - see Arrows
Double or Nothing Sudoku - see Cell Transform Sudoku
DoubleDoku
Doubler Sudoku - see Cell Transform Sudoku
Double X Sums - see X Sums
Doubling Lines
Dutch Whispers Lines - see Whispers Lines
Either-Or
Entropic Lines
Entropic Mirror - see Diagonal Mirrors
Entropic Whispers Lines - see Extended Whispers Lines
Entropki Dots (same/different entropy classes)
Entropy (see Global Entropy)
Entropy Battenburg (on a 2x2, no pair of same entropic cells are adjacent)
Entropy Quads (partial Entropy, asserts Entropy on an individual 2x2)
Equiparity/Uniparity Cages - see More-Odd-Than-Even Cages
Even Max Quads - see Quad Max Values
Even-Odd
Extended Whispers Lines
Extra Regions - see irregular Sudoku
Fast Thermos - see Thermos
First-Seen Parity/Entropy/Modular
Forbidden Consecutive Sums
Fortress
Friendly Cells
Full Rank
Gamma-Epsilon - see Kropki
Generalized Knightmare (see Anti-Knight)
Genetics
German Whispers Lines - see Whispers Lines
Given Digits
Global Entropy
Global Modular (see Global Entropy)
Global Neighbor Sums
Global Whispers (Dutch, et. al.)
Gurth's Symmetric Placement (GSP)
Indexing
Irregular Sudoku
Isotopes
Japanese Sum Sudoku
Keypad King Lines
Keypad Knight Lines
Killer Cages (repeating and non-repeating)
Knapp Daneben Cages - see Killer Cages
Knightmare (seee Anti-Knight)
Kropki (see Kropki Pairs)
Kropki Pairs
Line Sum Lines
Little Killer
Lockout Lines
Logic Bombs
Look-and-Say Cages - see Zones
Magic Lines
Magic Squares
Magnitude Mirror - see Diagonal Mirrors
MaxAscending
Maximin - see Minimax
Maximum Runs (Maximum Triplets)
Median Cages
Min-Max
Minimax
Missing Arrow - see Arrows
Missing Bulb Thermos - see Thermometers
Modular Lines
Modular Quads - see Entropy Quads
More-Odd-Than-Even/More-Even-Than-Odd Cages
Nabner Lines
Nearest Neighbor
Negator Sudoku - see Cell Transform Sudoku
Neighbor Sums
Next-To-Nine
No-Three-In-A-Row (Parity)
No Seven - see Forbidden Consecutive Sums
Non-Consecutive
Numbered Room
Odd-Even Thermos - see Thermometers
Odd Max Quad - see Odd Max Values
Openfaced Sandwich Sums - see Sandwich Sums
Order Sum Cages
Outside Clues
Outside Diagonal Clues
Palindrome Lines
Parindrome Lines - see Palindrome Lines
Parity Count Lines (endpoints show the number of odd/even digits along the line)
Parity Dots
Parity Lines (alternating parity along line)
Parity Mirror - see Diagonal Mirrors
Parity Party
Parity Quads (2x2 regions which contain both parities)
Parity Snakes
Pencilmarks
Psycho Killer Cages - see Killer Cages
Pointing Arrows - see Arrows
Pointing Differents
Position Sums
Primality Mirror - see Diagonal Mirrors
Punctured Cages - see Killer Cages
Quadruple
Quad Max Arrows
Quad Max Parity Values - see Odd Max Values
Quad Max Values
Quad Sums (one digit on a quad is the sum of the three others)
Quadro (no 2x2 in grid has all even or all odd digits) - see Parity Quads
QuattroQuadri
Ratio Pairs - see Kropki and Kropki pairs
Region Sum Lines (sum of all cells along a line in a region is fixed)
Region Segment Sum Lines - see Region Sum Lines
Renban Lines
Renrenbanban Lines (see Renban Lines)
Repeating Arrows - see Arrows
Repelling Digits
Reverse Numbered Rooms - see Numbered Rooms
Reverse X-Sums - see X-Sums
Rossini Clues
Rotational Pairs - see Gurth's Symmetric Placement
Run-On Renban Lines - see Renban Lines
Run-On Nabner Lines - see Extended Whispers Lines
Samurai Sudoku
Sandwich Sums
Scary Cells
Schr√∂dinger Cell Sudoku
Search Nine
Shaken Clone Regions - see Clone Regions
Shift Lines
Skyscrapers
Skyscraper Sums - see Skyscrapers
Slingshots
Slow Thermometers (see Thermometers)
Sum Dots (see Killer Cages)
Sum Sandwiches
Thermometers
Triple Tabs
Unicorn Digits
Uniparity/Equiparity Cages - see More-Odd-Than-Even Cages
Vaults
Weak Palindrome Lines
Windoku
X-Kropki
XSudoku
X-Sum
XV (see XV Pairs)
XV Pairs
XVXV
XY-Difference Pairs
Zipper Lines
Zones

Some Notes on Data Structures
-----------------------------
All cells are indexed as tuples, e.g. (4,6), per the following array:

----------------------------
|11|12|13|14|15|16|17|18|19|
----------------------------
|21|22|23|24|25|26|27|28|29|
----------------------------
|31|32|33|34|35|36|37|38|39|
----------------------------
|41|42|43|44|45|46|47|48|49|
----------------------------
|51|52|53|54|55|56|57|58|59|
----------------------------
|61|62|63|64|65|66|67|68|69|
----------------------------
|71|72|73|74|75|76|77|78|79|
----------------------------
|81|82|83|84|85|86|87|88|89|
----------------------------
|91|92|93|94|95|96|97|98|99|
----------------------------

When a constraint requires a cell or list of cells, they can be input in one of three ways:
1. Explicitly as a tuple, e.g., (5,6)
2. As a string, e.g., '85'
3. As an integer, e.g., 16.

Note: The non-tuple cell inputs WILL break on boards larger than 9x9. However, since 9x9 is by far the most popular use case, these shortcuts are worth having.

Quadruples are indexed similarly, from 11 to 88:

-------------------------------------
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---1,1-1,2-1,3-1,4-1,5-1,6-1,7-1,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---2,1-2,2-2,3-2,4-2,5-2,6-2,7-2,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---3,1-3,2-3,3-3,4-3,5-3,6-3,7-3,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---4,1-4,2-4,3-4,4-4,5-4,6-4,7-4,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---5,1-5,2-5,3-5,4-5,5-5,6-5,7-5,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---6,1-6,2-6,3-6,4-6,5-6,6-6,7-6,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---7,1-7,2-7,3-7,4-7,5-7,6-7,7-7,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
---8,1-8,2-8,3-8,4-8,5-8,6-8,7-8,8---
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
-------------------------------------

Edge constraints are indexed by the top- or left-most cell in the pair of adjacent cells. An additional parameter hv is provided to determine whether the pair is horizontal or vertical. The class variables Horz and Vert can be used for this designation. 

10 Lines
--------
set10Line(inlist,value): asserts a line that can be partitioned into non-overlapping segments, each of whose cells sum to the given value
  inlist: list of cell specifications
  value: Optional, default is 10. Value to which chunks on the line need to sum to

All Odd or Even
---------------
setAllOddOrEven(list): given a list of "shaded" cells defined by list, all shaded cells in each region have the same parity
  list: list of cell specifications

Alternate Digits
----------------
If a puzzle does not have a 1-9 digit set (0-8 being the most common alternative), then an alternate digit set can be added by including the digitSet parameter when instantiating the puzzle, e.g.,
p = ORsudoku.sudoku(boardSizeRoot,digitSet={0,1,2,3,4,5,6,7,8})

Anti-King
---------
setAntiKing(): applies the anti-king constraint to the whole puzzle

Anti-Knight
-----------
setAntiKnight(): applies the anti-knight constraint to the whole puzzle

setKnightMare(): applies the Knightmare constraint, where no two cells a knight's move apoart can sum to either 5 or 15.

setGeneralizedKnightMare(list): applies the Knightmare constraint with a specified list of forbidden sums at a knight's move apart. Defaults to standard knightmare.

Anti-Queen
----------
A strictly anti-queen sudoku does not exist, but there are several more limited constraints which do not allow certain repeats on diagonals

setAntiQueenDigit(values): asserts that no instances of a digit in the list values can repeat on any diagonal
	values: a single digit, or a list of digits
	
setAntiQueenCell(cell[cell2]): asserts that digit in this cell does not repeat on diagonals, or does not repeat on some diagonal
  cell: typical cell specification
  cell2: optional cell specification: if omitted, digit in first cell does not repeat on any diagonal. If present, cell does not repeat on diagonal in direction of r2,c2...most common usage is to have r2,c2 diagonally adjacent to original cell
  Can use shorthand, e.g. 5566 to indicate no repeats from 55 down the main diagonal
  
Arrows
------
setArrow(inlist): creates an arrow constraint
  inlist: a list of cells along arrow, where the first element of list is the circle
  
setDoubleArrow(inlist): creates a double arrow constraint - sum of cells between the endpoint equals the sum of the endpoints
  inlist: a list of cells along arrow, where the first element of list is the circle
  
setHeavyArrow(inlist,mult): creates a heavy arrow, where the sum of the cells along the arrow is a multiple of the first cell
  inlist: a list of cells along arrow, where the first element of list is the circle
  mult: Optional, default is 2. The factor by which the first cell is multiplied. By default, the cells on the arrow add up to twice the value in the bulb
  
setPointingArrow(list): creates a pointing arrow, which is both a regular arrow, and whose other end points (as determined by the last two cells) at another copy of the sum
  list: a list of cells along arrow, where the first element of list is the circle
  
setMultiDigitSumArrow(list,n): creates an arrow where the sum is multi-digit, interpreted base 10
  list: a list of cells along the arrow where the first n elements are in the circle, listed from most-significant to least significant
  n: the number of digits in the circle
  
setMissingArrow(list): an arrow where either end cell of the arrow may be the sum of the rest of the elements on the arrow
  list: a list of cells along arrow, where either the first or last element of list is the sum of the rest
  
setRepeatingArrow(list,repeat): an arrow where the arrow portion can be paritioned into contiguous cells whose sum is the value in the bulb
  list: a list of cells along arrow, where the first element of list is the circle
  repeat (optional): the number of times the circle sum will repeat, default is 2
  
Ascending Starters
------------------
setAscendingStarter(row,col,rc,value): specifies the sum of the ascending run (which may be only one digit) starting at the cell next to the clue
  row,col: The coordinates of a cell on either end of the row/column
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the sum of the ascending run of digits next to the clue
  
Average Lines
-------------
setAverageLine(inlist): creates an average line, where the first cell in the list is the average (arithmetical mean) of the cell values in the list
  inlist: a list of cells specifications
  
Battenburg
----------
setBattenburg(cell): creates a Battenburg constraint (no cells on the quad with the same parity share an edge)
  cell: a single cell specification, e.g., 13,'25',(4,7)
  
setBattenburgArray(list): creates multiple Battenburg constraints
  list: a list of cell specifications
  
setAntiBattenburg(cell): creates a negative Battenburg constraint (the Battenburg condition does NOT hold)
  cell: a single cell specification, e.g., 13,'25',(4,7)
  
setAntiBattenburgArray(list): creates multiple negative Battenburg constraints
  list: a list of cell specifications

setBattenburgNegative(): specify that all cells not specifically designated with Battenburgs do NOT satisfy the Battenburg constraint

Battlefield
-----------
setBattlefield(row,col,rc,value): implements a Battlefield constraint in a row or column
  row,col: The coordinates of a cell on either end of the row/column
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: summarized from Realshaggy: Consider the first x and last y cells of a row or column where x is the value of the first and y the value of the last cell. value is the sum of the digits where these groups overlap or the sum of the digits between these groups.
  
Between Lines
-------------
setBetweenLine(list): creates a between line constraint
  list: a list of cell specifications
  
Block Cages
-----------
setBlockCage(list,values): creates a block cage, that is an list of cells and a list of values, such that those values cannot appear within the cage
  list: list of cell specifications
  values: a list of values...if unambiguous the punctuation can be omitted, so that [1,2,3,9] and 1239 can both be entered as a value list

Capsules
--------
setCapsule(inlist): creates a capsule, i.e., a region with the same number of even and odd digits. See also More-Odd-Than-Even cages
  list: list of cell specifications

Cell Transform Sudoku
---------------------
Inspired by the doubler rules invented by zetamath. Grid is as normal, but one cell in each row, column and region is transformed when used in other constraints. To model cell transform contraints requires use of a different class:

p = ORsudoku.cellTransformSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  All three parameters are optional:
  canRepeatDigits: if canRepeatDigits is True, then the constraint that the base digits of all transformed cells need to be distinct is waived. Default is False
  irregular and digitSet are settable just like the regular Sudoku class

By default the cellTransformSudoku class just implements Doubler Sudoku. Doubler Sudoku can also be initialized with:
p = ORsudoku.doublerSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)

To implement other rulesets, one needs additional classes:

negatorSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  Just like doubler Sudoku, but the designated cells are negated, not doubled
  
doubleOrNothingSudoku(boardSizeRoot,canRepeatDigits,irregular,digitSet)
  The designated cells are either doubled, or count as zero, in other constraints. Note: this behavior is consistent; each cell is either doubled or nothing, and does not vary depending on which constraint is applied.
  
affineTransformSudoku(boardSizeRoot,ratio,shift,canRepeatDigits,irregular,digitSet)
  The parameters ratio and shift are required, and the transformed digits count as ratio*value+shift to all constraints.
  Doubler Sudoku is the same as affineTransformSudoku(3,2,0)
  Negator Sudoku is the same as affineTransformSudoku(3,-1,0)

Clock Lines
-----------
setClockLine(list): ceates a clock line, where adjacent cells on the line differ by either 2 or 7
  list: list of cell specifications

Clone Regions
-------------
setCloneRegion(list): creates a set of regions that are clones of each other, i.e., the same digit appears in the ith position for each i
  list: a list OF LISTS of cell specifications
  
setDominantCloneRegion(list,strict): creates a set of regions such that in every position, the first region has a digit larger than the corresonding digit in all other regions
  list: a list OF LISTS of cell specifications
  strict: OPTIONAL, defaults to True. If strict, dominant clone contains strictly greater than digits. If strict is False, this is relaxed to greater than or equal to.
  
setShakenCloneRegion(list,noRepeat): creates a set of regions that contain the same multi-set of digits
  list: a list OF LISTS of cell specifications
  noRepeat: OPTIONAL, defaults to False. If noRepeat, digits cannot repeat in the zone. By default, repeats are allowed.
  
Consecutive Chain Regions
-------------------------
setConsecutiveChainRegion(list): creates a region which has contains a set of consecutive digits such that an orthogonal snake can be drawn within the region from the lowest to the highest digit
	list: list of cell specifications
NOTE: do NOT use this constraint with countSolutions...the chain construction creates numerous free Booleans which can flap while leaving the numerical solution fixed

Consecutive Lines
-----------------
setConsecutiveLine(list): creates a line which consists of consecutive digits in order from lowest to highest (which end is lowest is not specified)
	list: a list of cell specifications
  
Consecutive Quads
-----------------
On a quad, a black dot indicates at least two pairs of cells in the quad, including diagonals, have consecutive digits, while a white indicates exactly one pair.

setConsecutiveQuadWhite(cell):	set a single white consecutive quad dot
	cell: single cell specification
	
setConsecutiveQuadWhiteArray(list): set multiple white consecutive quad dots
	list: a list of cell specifications
	
setConsecutiveQuadBlack(cell):	set a single black consecutive quad dot
	cell: single cell specification
	
setConsecutiveQuadBlackArray(list): set multiple black consecutive quad dots
	list: a list of cell specifications
	
setConsecutiveQuadArray(list): set multiple black/white consecutive quad dots
	list: a list of extended cell specifications, containing row/col, plus an indication of whether the dot is white (0) or black (1). Use the Black and White class variables for surety.
	
setAntiConsecutiveQuad(cell): asserts that there are no consecutive pairs of digits amongst the 6 pairs of digits in the quad
	cell: cell specification
	
setAntiConsecutiveQuadArray(list): assert multiple anti-consecutive quad conditions
	list: a list of cell specifications
	
setConsecutiveQuadNegative(): assert that all possible dots are given, so places without dots have no consecutive pairs

Corner/Edge Clues
-----------------
setCornerEdge(box,ce,valueList): sets a list of values that must appear in a corner or on an edge of a BOX (not region)
  box: integer denoting box, upper left corner is 1, to its right is 2, etc.
  ce: determines whether clue is for corners or edges. 0 or class variable Corner for corner, 1 or class variable Edge for edge
  valueList: list of cell values for which to assert placement

Count the Odds Lines
--------------------
setCountTheOddsLine(list): set a count the odds line, where the digit in the first cell of the line counts the number of odd digits on the rest of the line; pioneered by clover!
  list: list of cell specifications
  
Counting Circles
----------------
setCountingCircles(list): given a list of circled cells, a digit in a circled cell is the number of times that digit appears in a circled cell
  list: list of circle cells

Cupid Clues
-----------
setLittleCupid(row1,col1,row2,col2): sets a cupid clue: value in the cell (row1,col1) must also appear along the diagonal in the direction of (row2,col2)
  row1,col1: the cell spec of the cupid cell
  row2,col2: the cell spec for the next cell in the diagonal along which the cupid arrow points

David and Goliath Pairs
-----------------------
setDavidAndGoliath(list,borderDigit,borderType): sets a David and Goliath pair, where at least one cell must have a "David" (small) digit and at least one must have a "Goliath" (large) digit
  list: list of two cell specifications
  borderDigit: (Optional) digit that defines the border between small and large, defaults to 5
  borderType: (Optional) if -1, border digit is David and not Goliath; if 1, border digit is Goliath and not David; if 0, border digit is both David and Goliath (default is 0)

Descriptive Pairs
-----------------
setDescriptivePair(row,col,rc,values): clue on a row or column with two digits XY; either X is in Yth position, or Y is in Xth
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: A list or tuple of digits defining the pair. A 2-digit integer (e.g. 45) can also be given. Negative digits are allowed, and index from the opposite end of the row/column

Diagonal Consecutive Pairs
--------------------------
setDiagonalConsecutivePairs(cell):	asserts that the diagonal pairs on this 2x2 are consecutive digits
	cell: single cell specification
	
setDiagonalConsecutivePairsArray(list): set multiple diagonal consecutive pairs
	list: a list of cell specifications

Diagonal Mirrors
----------------
Diagonal mirrors allow the main and/or off diagonals to serve as mirrors, or anti-mirrors, for certain numeric properties. Currently supported properties are:
Entropy - low, middle, high
Magnitude - {1,2,3,4,5}, {5,6,7,8,9} (note: 5 is a wildcard and matches either set)
Parity
Primality - {1,2,3,5,7}, {1,4,6,8,9} (note: 1 is a wildcard and matches either set)

A mirror ensures that cells reflected across a diagonal have the same value for the property, an anti-mirror ensures those properties are different. Supported functions include:
setEntropyMirrorMain()
setEntropyMirrorOff()
setEntropyAntiMirrorMain()
setEntropyAntiMirrorOff()
setMagnitudeMirrorMain()
setMagnitudeMirrorOff()
setMagnitudeAntiMirrorMain()
setMagnitudeAntiMirrorOff()
setParityMirrorMain()
setParityMirrorOff()
setPrimalityMirrorOff()
setPrimalityAntiMirrorMain()
setPrimalityAntiMirrorOff()

Note that parity anti-mirror does not lead to any solutions, so it is not supported.

Different Neighbors
-------------------
setDifferentNeighbors(row,col,includeCell): asserts that the number of distinct digits in the neighborhood of (row,col) (including diagonals) is equal to the digit in the cell. Can optionally include the cell itself in the digit count
  row,col: cell specification
  includeCell: default False: if set includes the cell itself in the count of digits, default is to only count the 8 adjacent cells

Digit Count Cages
-----------------
setDigitCountCage(inlist,value): asserts that value is the number of distinct digits appearing in the cage; pioneered by clover!
  inlist: list of cell specifications
  value: integer counting number of distinct digits

Disjoint Groups
---------------
setDisjointGroups(): sets the global disjoint groups constraint

DoubleDoku
----------
To model a DoubleDoku puzzle, you must use the class doubleDoku, e.g.

p = ORsudoku.doubleDoku(boardSizeRoot)

The sub-Sudoku puzzles are labelled:
1
 2
 
The puzzles overlap with one box of fringe, so a 9x9 shares 4 boxes, and 16x16 shares 9 boxes, etc.

In this class, you can use the following method:
setDoubleDokuConstraint(puzzle,constraint,argsd): sets a DoubleDoku constraint
	puzzle: the puzzle number (1-2) to which the constraint should apply
	constraint: a string containing the name of the constraint (e.g. 'GivenArray')..do not include the 'set' used in the method name
	args: the arguments that you wish to pass to the constraint, just as if you were passing them with the normal 'set' method

Doubling Lines
--------------
setDoublingLine(list): creates a doubling line constraint: every digit appears exactly twice on the line
  list: a list of cell specifications

Either-Or
---------
setEitherOr(cellHVV): Given an extended cell specification with a row, column, a Horz/Vert, and a value, assert the given value appears in one of the two cells defined by the cellHV specification
  cellHVV: an extended cell specification which adds the hv parameter: circle is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical. A value is also given, defining the value to appear in either cell
  Example: 2518, '2518' and (2,5,p.Vert,8) all specify a circle on the bottom edge of cell 2,5, asserting either cell 25 or cell 35 is an 8
  
setEitherOrArray(list): assert multiple Either-Or constraints
  list: list of extended cell specifications, see setEitherOr

Entropic Lines
--------------
setEntropicLine(list): creates an entropic line constraint
  list: a list of cell specifications
  
Entropki Dots
-------------
Entropki dots are placed like Kropki dots, but white dots indicate the adjacent cells are of different entropic ranks, while black dots indicate the adjacent cells are of the same entropic rank.

setEntropkiWhite(cellHV): creates a white Entropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setEntropkiBlack(cellHV): creates a black Entropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setEntropkiWhiteArray(list): creates multiple white Entropki dots
  list: list of cellHV specifications, see setEntropkiWhite

setEntropkiBlackArray(list): creates multiple black Entropki dots
  list: list of cellHV specifications, see setEntropkiBlack
  
setEntropkiArray(list): creates multiple Entropki dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setEntropkiWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
Entropy Battenburg
------------------
setEntropyBattenburg(cell): creates an entropy Battenburg constraint (no cells on the quad of the same entropic rank share an edge)
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setEntropyBattenburgArray(list): creates multiple entropy Battenburg constraints
  list: a list of cell specifications
  
setAntiEntropyBattenburg(cell): creates an anti-entropy Battenburg constraint (some pair of adjacent cells on the quad have the same entropic rank)
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiEntropyBattenburgArray(list): creates multiple anti-entropy Battenburg constraints
  list: a list of cell specifications
  
setEntropyBattenburgNegative(): specify that all cells not specifically designated with entropy Battenburgs do NOT satisfy the entropy Battenburg constraint

Entropy Quads
-------------
setEntropyQuad(cell): creates an entropy constraint (all three entropic ranks must appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setEntropyQuadArray(list): creates multiple entropy quad constraints
  list: a list of cell specifications
  
setAntiEntropyQuad(cell): creates an anti-entropy constraint (all three entropic ranks cannot appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiEntropyQuadArray(list): creates multiple anti-entropy quad constraints
  list: a list of cell specifications
  
setEntropyQuadNegative(): specify that all cells not specifically designated with entropy quads do NOT satisfy the entropy quad constraint, i.e., some entropic rank will be missing around each quad which is not an entropy quad

The following analogous functions are available for modular quads, which are the same as Entropy quads, but use the modular grouping {1,4,7},{2,5,8},{3,6,9}

setModularQuad(cell): creates an entropy constraint (all three entropic ranks must appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setModularQuadArray(list): creates multiple entropy quad constraints
  list: a list of cell specifications
  
setAntiModularQuad(cell): creates an anti-entropy constraint (all three entropic ranks cannot appear in the quad) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiModularQuadArray(list): creates multiple anti-entropy quad constraints
  list: a list of cell specifications
  
setModularQuadNegative(): specify that all cells not specifically designated with entropy quads do NOT satisfy the entropy quad constraint, i.e., some entropic rank will be missing around each quad which is not an entropy quad

Even-Odd
--------
setEven(cell): asserts the cell value is even
  cell: single cell specification

setOdd(cell): asserts the cell value is odd
  cell: single cell specification
  
setEvenOdd(cellEO): asserts the parity of a cell
setOddEven(cellEO): asserts the parity of a cell
  cellEO: a cell specification augmented with an even odd specification. Tuple specification may use the Even and Odd variables, e.g. (5,8,p.Odd). Shorthand is possible, using 0 for even and 1 for odd. Thus 581 is an alternative specification for the same assertion.
  
setEvenArray(list): create multiple even constraints
  list: list of cell specifications
  
setOddArray(list): create multiple odd constraints
  list: list of cell specifications
  
setEvenOddArray(list): create multipl parity constraints
setOddEvenArray(list): create multipl parity constraints
  list: list of cellEO specifications; see setEvenOdd
  
Extended Whispers Lines
-----------------------
setMinExtendedWhispersLine(list,difference,reach): set contraint that cells at most reach cells apart on the line given by list differ by at least difference
	list: list of cell specifications
	difference: minimum difference between "close" cells
	reach: number of adjacent cells on line defining "close"
	
setMaxExtendedWhispersLine(list,difference,reach): set contraint that cells at most reach cells apart on the line given by list differ by at most difference
	list: list of cell specifications
	difference: maximum difference between "close" cells
	reach: number of adjacent cells on line defining "close"

setEntropicWhispersLine(list): line where cells at most two cells apart along the line differ by at least 3
	list: list of cell specifications
	
setRunOnNabnerLine(list): line where cells at most three cells apart along the line differ by at least 2; this is equivalent to the definition of a run-on nabner line analogous to a run-on renban line, as it assures that no two cells along any stretch of 5 in a line are consecutive
	list: list of cell specifications

First-Seen Clues
----------------
First-seen clues indicate the first value with a given property seen from outside the grid

setFirstSeenParity(row,col,rc,value): asserts the first digit with the parity of value seen in the row/column is the given value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: first even/odd value seen in the row/column
  
setFirstSeenEntropy(row,col,rc,value): asserts the first digit in the entropic stratum of value seen in the row/column is the given value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: first low/middle/high value seen in the row/column
  
setFirstSeenModular(row,col,rc,value): asserts the first digit with the same modulus as value seen in the row/column is the given value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: first value equal to 0/1/2 mod 3 seen in the row/column

Forbidden Conseuctive Sums
--------------------------
setNoConsecutiveSum(list): asserts that no pair of adjacent cells can have digits that sum to a value in the list
  list: list of forbidden sum values
  
setNoSeven(): asserts that adjacent cells may not sum to 7

Fortress
--------
setFortress(list): creates a Fortress constraint on a group of cells
  list: list of cell specifications
  
Friendly Cells
--------------
setFriendly(cell): creates a friendly cell, i.e., one whose value matches one or more of its row, column, or box number
	cell: single cell specification
	
setFriendlyArray(list): set multiple friendly cells
	list: list of cell specifications
	
setUnfriendly(cell): creates a cell that is not friendly, i.e., its value does NOT match row, column or box
	cell: single cell specification
	
setUnfriendlyArray(list): set multiple unfriendly cells
	list: list of cell specifications

setFriendlyNegative(): assert a negative constraint, namely that cells not marked friendly are NOT friendly

Full Rank
---------
setFullRank(row,col,rc,value): treating all 36 rows and columns (in both directions) as 9-digit integers, with most significant closest to the clue, and placing these values in numerical order, clue asserts that the associated row/column is the value_th smallest in the ordering, so 1 is the smallest, and 36 is the largest
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: rank of this row/column in the ordering
  
NOTE: full rank clues are only implemented for 9x9 boards or smaller, with digit set a subset of {0..9}. There are several differing but reasonable interpretations of how to deal with multi-digit numbers and full rank, sufficiently incompatible to prevent a unified attempt to implement here.

Genetics
--------
setGenetic(list): applies a genetic constraint to the cells: daughter must inherit parity/entropic rank from parents, and must inherit at least one from each
	list: a list of three cell specifications - first two are parent cells, last is daughter cell specification

setGeneticArray(list): applies genetic constraint to multiple specification lists
	list: a list of lists of cell specifications, where each element of the list is formatted per the setGenetic guidelines
 
Given Digits
------------
setGiven(cellVal): set the value in a particular cell
  cellVal: an extended cell specification that includes the value to be set. Shorthand is possible.
    Example: 289, '289' and (2,8,9) all designate a 9 given in row 2, column 8
	
setGivenArray(list): set multiple given digits
  list: a list of cellVal specifications; see setGiven
  
Global Entropy
--------------
setGlobalEntropy(): assert the Entropy condition on all quads. Effectively the same as setting entropy quads on all quads; see set EntropyQuad

setGlobalModular(): same as Entropy, but with modular digit grouping {1,4,7},{2,5,8},{3,6,9}

Global Neighbor Sums
--------------------
setGlobalNeighborSum(sums,exceptions): asserts that every cell with a digit not in exceptions must have an orthogonal neighbor with which it sums to a value in sums
  sums - list of allowed sums
  exceptions - list of digits excepted from the sum requirement

Global Whispers
---------------
setGlobalWhispers(diff,gle): assert a global whispers constraint: every cell has at least one neighbor with which it has a difference of at least, equal to, or at most diff.
  diff: The difference required. Default is 4
  gle: Specifies whether difference with neighbor must be greater than (2, use class variable GE), equal to (1, use class variable EQ) or less than (0, use class variable LE) diff. Default is 2, greater than.

Gurth's Symmetric Placement
---------------------------
Asserts that the the grid has symmetry based on 180 degree rotation plus some permutation of the digits.
setGSP(pairs): assert the GSP constraint
  pairs: a list of lists of pairs of digits whose placement implements the symmetry. Default is pairs that sum to the grid size + 1, e.g. (19,28,37,46). Computationally, this list does NOT need to be complete, so one could use this to assert that everywhere a 1 appears, a 7 appears in the rotational symmetric position, and leave it at that. Don't know if that makes for an interesting puzzle though.

setRotationalPairs(): assert the rotational pairs contraint: each digit has a partner digit which is always placed in cells under a 180 degree rotation. Like GSP, but pairs are not asserted in advance

Indexing (159)
--------------
****NOTE****
Older versions of OR Tools had a bug (https://github.com/google/or-tools/issues/3670) which caused the same solution to be reported multiple times. This has been fixed as of version 9.6.

setIndexRow(row,neg=False,inlist=[]): set an index row, namely one which indicates the position of the digit corresponding to the row within some subset of columns
  row: the row (1-9) used as an index. By default, all column positions index
  neg (optional): if a column position is indicated as not indexing, then position indicate specifically does NOT indicate the position of the digit. Default is False.
  inlist (optional): a list of which column positions (1-9) are indexing, with columns not in the list NOT indexing. Note: if inlist is not given, and neg=True, then code assumes *NO* cell in the row indexes. If inlist is not given, and new is True, or not given, then code assumes *ALL* cells in the row index.
  Example: If we call setIndexRow(5,True,[1,2,3,4,5,6,7,8]), then in all but the rightmost column, the entry in row 5, column X indicates which row contains a 5 in that column. So if 5,1 is a 2, then 2,1 must be 5. In the rightmost column, the 5 CANNOT appear in the row indicated by the entry in row 5. Specifically if 5,9 is a 3, then the entry in 3,9 CANNOT be a 5.

setIndexColumn(row,neg=False,inlist=[]): set an index column. See setIndexRow for details of the mechanics
  Example: The traditional 159 ruleset is implemented with the calls:
  setIndexColumn(1)
  setIndexColumn(5)
  setIndexColumn(9)
  
Irregular Sudoku
----------------
Note: for ALMOST all intents and purposes, regions are no different from killer cages of size 9. But regions are respected by regions sum lines, where cages are not.

To implement an irregular Sudoku puzzle, call the puzzle constructor with the irregular flag set, e.g.,
p = ORsudoku.sudoku(boardSizeRoot,irregular=True)

setRegion(list): creates an Irregular Sudoku region
	list: list of cell specifications
	
set Regions(list): create multiple irregular Sudoku regions
	list: list OF LISTS of cell specifications

Isotopes
--------
Note: this constraint is only accurate for 9x9 puzzles with boxes...created by rockratzero
setRRZRotor(): asserts that if any two boxes have the same center cell, then the other digits in each box appear in the same order, modulo rotation

Japanese Sum Sudoku
-------------------
To model a Japanese Sum Sudoku puzzle, you must use the class japaneseSumSudoku, e.g.

from japaneseSumSudoku import japaneseSumSudoku
p = japaneseSumSudoku(boardSizeRoot,numberOfColors,irregular,digitSet)
	boardSizeRoot is the edge size of a box, so 3 for standard sudoku
	numberOfColors is the number of different colors that can be shaded...does not count unshaded as a separate color. Defaults to 1.
	irregular - set to true if regions in the sudoku are irregular. The regions are then defined with setRegion...see Irregular Sudoku. Defaults to standard boxes.
	digitSet - allows setting with an alternate digit set.

In this class, you can use the following method to set constraints
setJapaneseSum(row,col,rc,value): sets a Japanese sum constraint
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: A list of values representing the sums in a clue. If there is only one color, this list can be given as a list of integers, e.g., [2,5,17]. However, if multiple colors are used, the list elements should be tuples (sum,color), where the sum is the sum of digits in the shaded group, and color is the color. Colors are given as integers starting at 1 (internally, unshaded is color 0, but it has special rules).
  
  Ambiguous clues *are* supported: if a clue is given with a sum of zero, then the total sum of the shaded group is not checked. If a clue is given with a color of zero, then there must be a shaded group with the given sum, but the color is not checked. If both sum and color a zero, there must be another shaded group, but sum and color are unchecked.
  
If you wish to change the default color scheme for the printout of findSolution, this can be done with the setColorMap method. HOWEVER, you need to import the colorama class variables into your code as:

from colorama import Fore,Back

Then, you can set your color map as in this example:
p.setColorMap([(Fore.WHITE,Back.CYAN),(Fore.BLACK,Back.WHITE),(Fore.BLACK,Back.GREEN),(Fore.WHITE,Back.BLACK)])

In this example, the *unshaded* cells will be white numbers on a cyan background. Color 1 will be black digits on a white background, etc.

Keypad King Lines
-----------------
setKeypadKingLine(list): creates a keypad king line constraint (adjacent digits must be a king's move apart on a telephone keypad). Designed by Zegres
  list: a list of cell specifications
  
Keypad Knight Lines
-------------------
setKeypadKnightLine(list): creates a keypad knight line constraint (adjacent digits must be a knight's move apart on a telephone keypad). Designed by Zegres.
  list: a list of cell specifications
  
Killer Cages
------------
setCage(list,value): creates a killer cage with all cell values distinct
  list: list of cell specifications indicating the cells in a killer cage
  value (optional): if given, indicates the sum of the digits in the cage
  Note: sum dots can be implemented computationally with a killer cage, since this method does not require any particular relationship amongst the cells.
  
setRepeatingCage(list,value): creates a killer cage where values may repeat
  list: list of cell specifications indicating the cells in a killer cage
  value: indicates the sum of the digits in the cage
  
setPsychoKillerCage(list,value): creates a psycho killer cage, where the elements of the cage *provide a reference* to the digit in the same relative position in the box indicated by the cage element, and the sum of the referred digits is given
  list: list of cell specifications of cells in the cage
  value: sum of the referred cells
  
setPuncturedCage(list,value,puncture): creates a punctured cage, where the value is the sum of all but puncture digits in the cage
  list: list of cells in the cage
  value: sum of subset of the cells
  puncture: (optional, default is 1) number of cells punctured from the sum
  
setKnappDanebenCage(list,value): creates a killer cage with all cell values distinct, where the sum of the digits is either one greater or one less than the given digit
  list: list of cell specifications indicating the cells in a killer cage
  value: indicates the sum of the digits in the cage, plus or minus 1.
  
Kropki and Kropki Pairs
-----------------------
setKropkiWhite(cellHV): creates a white Kropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiBlack(cellHV): creates a black Kropki dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiGray(cellHV): creates a gray Kropki dot, which can be either a white or black dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setKropkiWhiteArray(list): creates multiple white Kropki dots
  list: list of cellHV specifications, see setKropkiWhite

setKropkiBlackArray(list): creates multiple black Kropki dots
  list: list of cellHV specifications, see setKropkiBlack

setKropkiGrayArray(list): creates multiple gray Kropki dots
  list: list of cellHV specifications, see setKropkiGray

setKropkiArray(list): creates multiple Kropki dots
  list: list of cellHVWBG specifications, which include a cell spec, the HV spec as given in setKropkiWhite, and a WBG spec, specifying the color of the dot. When given as a tuple, the White, Black and Gray variables can be used to specify W/B. Shorthand is possible, with white being 0, black 1, and gray 2.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
setAntiKropki(cellHV): asserts that the digits are neither consecutive or in a 2-to-1 ratio by default...uses kropkiDifference and kropkiRatio if these have been changed
	cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V.

setAntiKropkiArray(list): creates multiple anti-Kropki constraints
  list: list of cellHV specifications, see setKropkiWhite
  
setKropkiNegative(): implements true Kropki rules with a negative constraint

To change the values used for difference for white dots, and ratio for black dots, you can use the following methods:
setKropkiDifference(value)
setKropkiRatio(value)

The values can be reset to their defaults by calling them with no argument. All dots added subsequently to these calls will use the new values, without changing constraints already entered. HOWEVER, if a negative constraint is applied, it will ALWAYS use the final set value of these two variables to apply the negative constraint against.

setGammaEpsilon(): implement Gamma Epsilon rules, equivalent to setKropkiDifference(5) & setKropkiRatio(3)

Line Sum Lines
--------------
setLineSumLine(list): asserts that one of the cells on the line is the sum of all remaining cells on the line. See Missing Arrow constraints under Arrows.
  list: a list of cell specifications

Little Killers
--------------
setLittleKiller(row1,col1,row2,col2,value): sets a little killer diagonal constraint
  row1,col1: the cell spec of the first cell in the little killer diagonal, next to the clue
  row2,col2: the cell spec for the second cell in the diagonal (this seemed easier than some arbitary spec to define diagonals)
  
Lockout Lines
-------------
setlockoutLine(list): creates a lockout line constraint
  list: a list of cell specifications
  
Logic Bombs
-----------
setLogicBomb(row,col): asserts a cell is a logic bomb, so that it and its 8 knightly neighbors are all distinct digits
  row,col: cell specification
  
assertNumberOfLogicBombs(n): asserts that there are at least n logic Bombs in the grid (10 is max for 9x9)
  n: positive integer

Magic Lines
-----------
setMagicLine(list): create a magic line, where each set of four consecutive cells along the line contains one or more set of three consecutive cells whose sum is 15
  list: list of cell specifications

Magic Squares
-------------
setMagicSquare(cell): creates a magic square with given cell the upper left corner
  cell: single cell specification

Max Ascending
-------------
setMaxAscending(row,col,rc,value): sets a max ascending constraint, specifying the longest consective run of increasing digits in the row/col, looking from the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the length of the longest run of increasing digits in the row/col

Maximum Runs
------------
setMaximumRun(row,col,rc,value,length): asserts that in a row/column, the maximum sum of any "length" consecutive digits is value
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: maximum sum achievable
  length: number of consecutive digits to sum. Optional, default is 3.
  
setMaximumTriplet(row,col,rc,value): original formulation, maximum Run with length 3

Median Cages
------------
setMedianCage(list,value): sets the median value in the region (which must appear in the region)
	list: list of cell specifications
	value: target median value

Min-Max
-------
setMinCell(cell): assert a cell is smaller than all orthogonally adjacent cells
  cell: single cell specification
  
setMaxCell(cell): assert a cell is larger than all orthogonally adjacent cells
  cell: single cell specification
  
setMinArray(list): set multiple minimum cells
  list: list of cell specifications
  
setMaxArray(list): set multiple maximum cells
  list: list of cell specifications
  
setMinMaxCell(cellMM): set a minimum or maximum constraint
setMaxMinCell(cellMM): set a minimum or maximum constraint
  cellMM: an extended cell specification which adds the minmax parameter. All parameters can be given positionally, or in a tuple, and these can use the Min and Max variables for the minmax specification. Shorthand is possible, appending 0 to a cell spec to indicate a minimum and 1 to indicate a maximum.
  
setMinMaxCellArray(list): set multiple min/max constraints
setMaxMinCellArray(list): set multiple min/max constraints
  list: list of cellMM specifications; see setMinMaxCell
  
Minimax
-------
setMinimax(row,col,rc,value,length): asserts the sum of the largest and smallest digits in the target range is value
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value that is the minimax sum
  length (optional): by default, the target range is the cells in the region including the cell next to the clue.
                     If length is given, the target range is the first length cells from the cell next to the clue, regardless of regions.
					 
setMaximin(row,col,rc,value,length): asserts the difference of the largest and smallest digits in the target range is value
  Options same as setMinimax

Modular Lines
-------------
setModularLine(list): creates a modular line constraint
  list: a list of cell specifications
  
More-Odd-Than-Even Cages
------------------------
A MOTE cage has more odd digits than even digits, and a METO cage is the reverse

setMOTECage(list): set a MOTE cage
	list: list of cell specifications

setMETOCage(list): set a METO cage
	list: list of cell specifications
	
setEquiparityCage(list): set a cage with an equal number of even and odd digits; see also Capsules
	list: list of cell specifications

setUniparityCage(list): set a cage with enitrely even or entirely odd digits
	list: list of cell specifications

Nabner Lines
------------
setNabnerLine(inlist): assert that there are no two digits lying on the line are the same or consecutive
	inlist: list of cell specifications

Nearest Neighbor
----------------
setNearestNeighbor(row,col,pointers): arrows in a cell point to the orthogonal neighbor that has the closest digit; multiple arrows may occur if two or more neighbors are equidistant
	row,col: the cell in question
	pointers: a *list* of directions: use class variables Up, Down, Left and Right

Neighbor Sums
-------------
setNeighborSum(cell): asserts a cell is the sum of its orthogonally adjacent neighbors
	cell: single cell specification
	
setNeighborSumArray(list): asserts multiple neighbor sum constraints
	list: list of cell specifications
	
Note: setNeighbourSum and setNeighbourSumArray aliases are supported

Next-to-Nine
------------
setNextToNine(row,col,rc,values,digit): given a set of 1/2 digits on a row/column, these digits must appear in next to the nine in that row/column
  row,col: The coordinates of the cell containing the clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: A list of values to go next to 9; if only one value is given it may be given as an integer
  digit (optional): defines which digit is the one the clued digits must appear next to...defaults to 9

No Three in a Row (Parity)
--------------------------
setNoThreeInARowParity(): assert that in any row/column, there are no three consecutive odd digits nor are there three consecutive even digits

Non-Consecutive
---------------
setNonConsecutive(n): sets the global non-consecutive cells constraint
	n: Optional. By default, n=2 and there are no pairs of adjacent cells with consecutive digits. If n>2, then no set of n contiguous cells in a row or column can consists of a set of n consecutive digits.

Numbered Rooms
--------------
setNumberedRoom(row,col,rc,value): sets a numbered room constraint
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell
  Note: for negative digits, the behavior of a Numbered Room is to count cells from the other side of the row/column, a la a reverse Numbered Room
  
setReverseNumberedRoom(row,col,rc,value): sets a reverse numbered room constraint, i.e., If the clue is X, the value is placed in cell X counting from the *other*, non-clue end of the row/column.
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell
  Note: for negative digits, the behavior of a reverse Numbered Room is to count cells from the other side of the row/column, a la regular Numbered Room

Order Sum Cages
---------------
setOrderSumCages(list,slow,repeat): a set of cages with indeterminate sums, but whose sum order increases directly with order in the list
  list: a list OF LISTS of cell specifications
  slow: Optional, default is False. If False, each cage sum must be strictly less than its successor. If True, relationship is less than or equal.
  repeat: Optional, default is False. If False, digits may not repeat in cages. If True, digits may repeat.
  
Outside Clues
-------------
setOutside(row,col,rc,valueList): provides a set of values on a row or column that must appear in that row/column in the first box (region for irregular sudoku) appearing next to the clue; also option for using a fixed number of cells...see setOutsideLength
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  valueList: a list of values to be placed
  
setOutsideLength(num): sets a fixed length for outside clues, independent of regions

setOutsideDiagonal(r1,c1,r2,c2,valueList): provide a set of values that must appear along a diagonal containing r1c1 and r2c2; defaults to limiting diagonal to a region, but canuse a fixed length as well...see setOutsideLength
  r1,c1: Coordinates of cell next to clue
  r2,c2: Coordinates of second cell along the diagonal
  valueList: List of values to appear along the diagonal within the region (default) or a fixed number of cells

Palindrome Lines
----------------
setPalindromeLine(list): creates a palindrome line constraint
  list: a list of cell specifications
  
setParindromeLine(list): creates a parindrome line constraint, where only parity has to match 
  list: a list of cell specifications
  
Parity Count Lines
------------------
setParityLine(list): creates a parity count line constraint (inspired by Richard Stolk https://logic-masters.de/Raetselportal/Raetsel/zeigen.php?id=000B15, endpoints contain the number of odd/even digits along the line, in some order))
  list: a list of cell specifications
  
Parity Dots
-----------
Parity dots are placed like Kropki dots, but white dots indicate the adjacent cells are of different parities, while black dots indicate the adjacent cells are of the same parity.

setParityDotWhite(cellHV): creates a white parity dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setParityDotBlack(cellHV): creates a black parity dot
  cellHV: an extended cell specification which adds the hv parameter: dot is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a dot on the bottom edge of cell 2,5
  
setParityDotWhiteArray(list): creates multiple white parity dots
  list: list of cellHV specifications, see setParityDotWhite

setParityDotBlackArray(list): creates multiple black parity dots
  list: list of cellHV specifications, see setParityDotBlack
  
setParityDotArray(list): creates multiple parity dots
  list: list of cellHVWB specifications, which include a cell spec, the HV spec as given in setParityDotWhite, and a WB spec, specifying the color of the dot. When given as a tuple, the White and Black variables can be used to specify W/B. Shorthand is possible, with white being 0 and black 1.
  Example: 1701 incidates a black dot (1 WB spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.Black)
  
Parity Lines
------------
setParityLine(list): creates a parity line constraint (parity must alternate along the line)
  list: a list of cell specifications
  
Parity Party
------------
setParityParty(row,col,rc,value): sets a parity party constraint, where either the digit next to the clue equals the value, or the sum of all of the values up to and including the first digit that varies in parity from all prior cells
  row,col: The coordinates of the cell containing the indexing clue, i.e. the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The value (1-9) to be placed based on the indexing cell

Parity Quads
------------
setParityQuad(cell): creates an parity constraint (both parities must appear) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setParityQuadArray(list): creates multiple parity quad constraints
  list: a list of cell specifications
  
setAntiParityQuad(cell): creates an anti-parity quad constraint (quad is all even or all odd) for an individual quad
  cell: a single cell specification, e.g., 13,'05',(4,7)
  
setAntiParityQuadArray(list): creates multiple anti-parity quad constraints
  list: a list of cell specifications
  
setParityQuadNegative(): specify that all cells not specifically designated with parity quads do NOT satisfy the parity quad constraint, i.e., all cells must be either odd or even

setParityQuadExclusions(list): sets a list of numbers of *odd* digits not permitted in a 2x2
	list: list of integers defining numbers of forbidden odd digits in a 2x2. Default is [0,4]. Calling the function with no arguments sets the forbidden values back to the default.

All parity quads added subsequently to these calls will use the new values, without changing constraints already entered. HOWEVER, if a negative constraint is applied, it will ALWAYS use the final list of exclusions to apply the negative constraint against.
	
setQuadro(): assert that all 2x2 quads are parity quads; with default settings, sets to the traditional definition of no 2x2 quad having all even or all odd digits

Parity Snakes
-------------
setParitySnake(row1,col1,row2,col2,parity): asserts that there exists a path of constant parity from ro1,col1 to row2,col2
	row1,col1: position of first cell
	row2,col2: position of second cell
	parity: Optional: you may assert the snake has a particular parity with the Odd and Even class variables. By default, the snake may be either parity
  
Pencilmarks
-----------
setPencilmarks(row,col,values): set pencilmarks (possible values) for a single cell
	row,col: position of cell
	values: list of possible values for the cell
	Note: instead of three positional arguments, one can use a shorthand without punctuation, e.g. 12378 assigns pencilmarks 3/7/8 to cell 1,2.
	
setPencilmarksArray(list): set multiple pencilmark constraints
	list: a list of shorthand pencilmark specifications, e.g. [12123,15289]

Pointing Differents
-------------------
setPointingDifferents(row1,col1,row2,col2,value): asserts that there are only value different digits on the diagonal containing (row1,col1) and (row2,col2)
  row1,col1: the cell spec of the first cell in the little killer diagonal, next to the clue
  row2,col2: the cell spec for the second cell in the diagonal

Position Sums
-------------
setPositionSum(row,col,rc,value1,values2): set a position sum, namely giving the sum (value1) of the first two cells adjacent to the clue (determined by row,col) and the sum of the two cells indexed by the first two cells in the column.
  row,col: The coordinates of the cell containing the cell next to which the clue values sit
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value1: The sum of the first two cells from the clue direction
  value2: The sume of the cells indexed by the first two cells from the clue direction (see Indexing)

Quadruple
---------
setQuadruple(cellVals): create a quadruple constraint on a 2x2 region
  cellVals: an extended cell specification which adds a list of values appearing in the quad to the cell specification. Shorthand is possible, e.g. 67235 will indicate the quad at 6,7 contains values 2, 3, and 5.
  
setQuadrupleArray(list): set multiple quadruples
  list: list of cellVal specifications; see setQuadruple
  
Quad Max Arrows
---------------
setQuadMaxArrow(cellDir): constraint on a 2x2 points to the unique maximum value in the quad
  cellDir: an extended cell specification which has the coordinates of the 2x2, followed by a direction specification which uses a pair of 01 values to indicate Top/Bottom,Left/Right, in order. The class variables Top, Bottom, Left and Right can be used. So for example, 1401 and (1,4,p.Top,p.Right) both indicate that the cell 15 should be larger than all of 14, 24 and 25.
  
setQuadMaxArrowArray(list): set multiple Quad Max arrow constraints
  list: list of extended cell specifications per setQuadMaxArrow method
  
Quad Max Values
---------------
setQuadMaxValue(cellValue): constraint on a 2x2 indicating the maximum value in the quad
  cellValue: an extended cell specification which has the coordinates of the 2x2, followed by the maximum value in the quad
  
setQuadMaxValueArray(list): set multiple Quad Max value constraints
  list: list of extended cell specifications per setQuadMaxValue method
  
setQuadMaxParityValue(row,col,values,unique): 2x2 constraint indicating the largest value *of its parity* appearing in the quad
  row,col: the coordinates of the quad being clued
  values: a list of up to two values (one of each parity) which are specified as the maximum
  unique: Optional, if True, forces the maximum parity value to be unique. Default is True.
  Note: If using the default unique=True, the argument can be specified in shorthand without punctuation, e.g., 1234, meaning quad 1,2 has max odd 3 and max even 4.

Quad Sums
---------
setQuadSum(cell): assert that one of the digits in a quad is the sum of the other 3
  cell: single cell specification
  
setQuadSumArray(list): set multiple quad sum constraints
  list: list of cell specifications

QuattroQuadri
-------------
To model a QuattroQuadri, you must use the class quattroQuadri, e.g.

p = ORsudoku.quattroQuadri(boardSizeRoot,gridSize,irregular,digitSet)
	Assuming standard square regions, boardSizeRoot is the number of rows/columns in each region, and grid size is number of regions in each row/column of the grid. So a standard QuattroQuadri would have boardSizeRoot = 3 and gridSize = 2. These are the defaults, and need not be given in the declaration.
	
	irregular allows the possibility of setting irregular regions. Set to True and use the setRegion method to define regions. Default is False.
	
	digitSet is the set of digits allowed. Default is {1,2,3,4,5,6,7,8,9}.
	
	So a standard QuattroQuadri puzzle can be defined via p = ORsudoku.quattroQuadri(), with no options set.

Region Sum Lines
----------------
See Irregular Sudoku's setRegion method to set regions that affect Region Sum Lines. By default regions are the boxes in normal Sudoku rules.
setRegionSumLine(list): asserts that the sum of all cells on the line in each region is fixed across regions, regardless of contiguity along the line
  list: list of cell specifications
  
setRegionSegmentSumLine(list): asserts that the sum of cells on line in each visit to a region is fixed, with discontiguous segments in a region counted as different visits
  list: list of cell specifications
  
Renban Lines
------------
setRenbanLine(list): set a Renban line constraint
  list: list of cell specifications
  
setRunOnRenbanLine(list,n): set a run-on Renban line, i.e. a line where each contiguous subsegment of length n is a Renban line
  list: list of cell specifications
  n: length of subsegment that is a Renban. If not present, defaults to 5
  
setRenrenbanbanLine(list): line consists of two renban sets, whose digits may overlap
	list: list of cell specifications
NOTE: do not use with countSolutions...has unconstrained Booleans that will give multiple solutions for each set of digits
  
setNotRenbanLine(list): asserts that a set of digits does NOT form a Renban line
  list: list of cell specifications
  
Repelling Digits
----------------
setRepellingDigit(value,list): assert that no cell containing digit value can be orthogonally adjacent to a cell containing a digit from list
  value: the value of the repelling digit
  list: list of digits that value repels

Rossini Clues
-------------
Rossini clues appear as arrows on the outside of of the grid, and indicate that the first few cells next to the clue increase in the given direction. In normal Sudoku there is no ambiguity, since the number of cells used is 3, but is that 3 because of the region, or because 3 is a nice number? We provide the option to define the length of the run applied either by using regions, or specifying a value.

setRossini(row,col,uldr): sets a Rossini constraint on a row or column
  row,col: The coordinates of the cell next to which the clue values sit
  uldr: Determines if the arrow points Top/Bottom (for columns) or Left/Right (for rows)...use class variables Up, Down, Left, and Right
  By default, Rossini conditions operate on regions
  
setRossiniLength(value): changes cluing behavior to work on a fixed number of cells from the border
	value: number of cells to test for increase/decrease
	
setRossiniNegative(): assert a negative constraint on the Rossini conditions, i.e. rows/columns without clues do not strictly increase/decrease in the Rossini window

Samurai Sudoku
--------------
To model a Samurai Sudoku puzzle, you must use the class samuraiSudoku, e.g.

p = ORsudoku.samuraiSudoku(boardSizeRoot)

The 5 sub-Sudoku puzzles are labelled
1 2
 3
4 5

In this class, you can use the following method:
setSamuraiConstraint(puzzle,constraint,argsd): sets a Samurai constraint
	puzzle: the puzzle number (1-5) to which the constraint should apply
	constraint: a string containing the name of the constraint (e.g. 'GivenArray')..do not include the 'set' used in the method name
	args: the arguments that you wish to pass to the constraint, just as if you were passing them with the normal 'set' method

Sandwich Sums
-------------
setSandwichSum(row,col,rc,value,digits): sets a sandwich sum constraint
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the values between the 1 and 9 in the clued row/column
  digits (optional): A list of two digits to form the "bread" of the sandwich. Defaults to the minimum and maximum digit.
  
setOpenfacedSandwichSum(row,col,rc,value,digit): set an open-face sandwich sum clue, i.e. the sum of all digits in the row/col up to a bread digit
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the values before the sandwich digit in the clued row/column
  digit (optional): The sandwich digit. Optional, defaults to 9.
  
setBeforeNine(row,col,rc,value): an alias for Openfaced sandwich sums, with sandwich digit 9
  
Scary Cells
-----------
setScary(row,col,diff): set a scary cell, i.e. a cell all of whose neighbors (orthogonal and diagonal) differ from it by at least diff
  row,col: the coordinates of the cell
  diff: Optional, default = 3...sets the difference required for neighboring cells of a scary cell
  
There is a grid-wide version of scary cells that asserts there is a scary cell in each row, column and region. Use:
p = ORsudoku.scarySudoku
The arguments to this constructor are the same as for sudoku, except for the additional parameters:
  diff: Optional, default = 3, sets the difference between scary cells and their neighbors
  noDiag: Optional, default is False, asserts there are no scary cells on the same diagonal (anti-queen)
  allDifferent: Optional, default is Fase, asserts that the digits in scary cells are all different

Schr√∂dinger Cell Sudoku
-----------------------
Allows creation of puzzles with Schr√∂dinger cells. An additional digit (usually 0) is added, and one cell in each row, column and region is a Schr√∂dinger cell, which has two values. When used in constraints, it is considered to contain both values. Not all constraints work with Schr√∂dinger cells, and most have multiple interpretations. They are detailed below.

To model a Schr√∂dinger Cell Sudoku puzzle, you must use the class schroedingerCellSudoku, e.g.

p = ORsudoku.schroedingerCellSudoku(boardSizeRoot)

  Note: the conventions around how S-cells interact with constraints are not standardized, so this attempts to be flexible. Particular issues:
  1. Constraints such as extra regions and X sudoku normally elide the difference about whether all the digits in the area are the same, or whether all digits appear; these are equivalent in normal Sudoku. Here, the default behavior is to assume all digits appear, which forces an S-cell. However, but setting the "allDigits=False" flag in some some method calls, this behavior can be suppressed, and these constraints will only enforce that all digits are different.
  2. Constraints which use addition are fairly consistent that, when used as a summand, both digits of an S-cell should be added to the total. However, with conditions such as arrow clues, it is not obvious what to do if the target sum is an S-cell. By default, this code assumes that such a target sum CANNOT be an S-cell, since the sum assertion cannot possibly be true for both values. However, some puzzles assert that the sum of the Schr√∂dinger cell digits should be the target sum, and this behavior is support with the "sSum=True" flag.

  Implemented Constraints
  -----------------------
  Anti-king
  Anti-knight
  Arrows (including Double Arrows)
  Between lines - all digits on the line must be less than all digits on one end point and greater than all digits on the other end poit
  Block Cages
  Disjoint Groups - allDigits=False can be applied
  Even/Odd
  Given digits - setting a given digits enforces the corresponding cell is not a Schr√∂dinger cell
  Killer cages
  Kropki - if either cell is Schr√∂dinger, both digits have to have the specified relationship with the counterpart
  Min/max cells - the less than/greater than comparisons are made against both values
  Neighbor Sum - sSum=True can be applied
  Nonconsecutive
  Numbered Rooms - code assumes index cell cannot be Schr√∂dinger
  Parity Lines
  Region Sum Lines
  Renban Lines
  Thermos/Slow Thermos
  Unicorn Digits
  Vaults
  Windoku - allDigits=False can be applied
  X/Diagonal Sudoku - allDigits=False can be applied
  XV
  XVXV
  X-Sums - sSum=True can be applied to toggle whether S-cell sum is applied to indexing clue

  Schr√∂dinger Specific Concerns
  ----------------------------
  When specifying given digits with setGiven and setGivenArray, the syntax to indicate the definition is extended. If specified with 3 digits only, e.g. 145, setGiven will set the indicated cell (14) equal to the given value (5), and asserts it is NOT a Schr√∂dinger cell. If specified with 4 digits, the behaviors depends on whether the two given digits are equal or not. If they are not equal, then setGiven will set both values in the cell, and designate it a Schr√∂dinger cell. If these two given digits are equal, setGiven does assert that value is in the cell, but leaves it ambiguous whether or not that cell is a Schr√∂dinger cell.
  
  There are some additional methods with Schr√∂dinger cells:
  
  setIsSCell(cell): asserts that the indicated cell is a Schr√∂dinger cell
    cell: rowcol or (row,col) cell specification
	
  setIsSCellArray(list): set a list of cell specifications to be Schr√∂dinger cells
  
  setIsNotSCell(cell): asserts the indicated cell is not a Schr√∂dinger cell
    cell: rowcol or (row,col) cell specification
	
  setIsNotSCellArray(list): set a list of cell specifications to not be Schr√∂dinger cells

There is an alternative class for Schr√∂dinger sudoku, called superpositionSudoku. In this instance, the constraints are defined to be more akin to classic superposition, where either value can be used, and thus the values are never added or averaged. Each independently needs to be able to satisfy the constraint, perhaps with help from other S-cells. So for example, an arrow constraint with bulb 5/7 and arrow cells 2 and 3/5 would be legal, since 5,2,3 is a valid solution, as is 7,2,5. For another example, a Renban line could be 48,5,6,7, since either the 4 or 8 could pair with the other three digits, but 45,6,7,8 is not legal, since 4,6,7,8 is not a set of consecutive digits. On the gripping hand, 38,47,5,6 IS a legal renban assignment, since 3456 is legal, and 8756 is also legal. So not every combination of S-cell values needs to be legal, just at least one legal assignment for each value in each S-cell.

This class is under development, and the only safe constraints to use at this point are:
  Anti-king
  Anti-knight
  Arrows (including Double Arrows)
  Between lines
  Block Cages
  Disjoint Groups
  Even/Odd
  Given digits
  Min/max cells
  Parity Lines
  Renban Lines
  Thermos/Slow Thermos
  Unicorn Digits
  Vaults
  X/Diagonal Sudoku

Search Nine
-----------
setSearchNine(row,col,uldr,digit): Arrow gives direction, cell value a distance to a cell with value digit.
  row,col: The coordinates of the cell in which the clue values sit
  uldr: Determines if the arrow points Up/Down/Left/Right...use class variables Up, Down, Left, and Right
  digit: The value of the digit pointed to; optional, defaults to 9
  
Shift Lines
-----------
setShiftLine(inlist): sets a shift line constraint; like a palindrome, but one side is uniformly one larger than the other
  inlist: list of cell specifications

Skyscrapers
-----------
setSkyscraper(row,col,rc,value): sets a skyscraper constraint, specifying the number of digits that can be "seen" from the clue, where seen means greater than all digits between it and the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the number of digits that can be seen
  
setSkyscraperSum(row,col,rc,value): sets a skyscraper sum constraint, specifying the SUM OF the number of digits that can be "seen" from the clue, where seen means greater than all digits between it and the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: the sum of digits that can be seen
  
Slingshots
----------
setSlingshot(row,col,tail,head): assert that the digit pointed to by tail from (row,col) is equal to a cell pointed at by head, where the distance to this second occurrence is the digit in the cell (row,col)
  row,col: The coordinates of the cell in which the slingshot arrow lies
  tail: the direction in which the tail of the arrow points; use class variables Up, Down, Left, Right
  head: the direction in which the head of the arrow points; use class variables Up, Down, Left, Right

Sum Sandwiches
--------------
setSumSandwich(row,col,rc,values,neg=False): sets a sum sandwich - in a row/column, each value in values is the sum of its neighbors, e.g., the 9 in that row/column must be between two digits that sum to 9
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  values: a list of values who are the "filling" in a sum sandwich in the designated row/column
  neg: Optional, default False. Asserts that digits not in the value list are *not* the sum of their neighbors
  
Thermometers
------------
setThermo(list,slow,missing,speed): asserts that the values in cells increase from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  slow: set thermo to slow (i.e., nondecreasing vs. increasing); Optional: defaults to False, can also use setSlowThermo
  missing: set thermo to have missing bulb, so increase may start from either end; Optional: defaults to False, can also use setMissingThermo.
  speed: provides several options about the speed of the thermo, i.e., the level of difference between consecutive values. Allowable values are:
    'slow': Same as setting slow=True
	'fast': Ensures that each value along a fast thermo is at least two larger than the previous cell, can also use setFastThermo
	integer: Each value along a thermo is strictly greater than the previous value plus the speed. So speed=1 is equivalent to speed='fast'
  
setSlowThermo(list,missing): asserts that the values in cells do not decrease from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  missing: Optional, defaults to false. See setThermo
 
setFastThermo(list,missing): asserts that the values in cells increase by at least 2 from the beginning of the line to the end
  list: list of cell specifications, with bulb end of thermo being the first element
  missing: Optional, defaults to false. See setThermo
  
setOddEvenThermo(list,slow,missing): asserts that the values in cells increase from the beginning of the line to the end, and all have the same parity
  list: list of cell specifications, with bulb end of thermo being the first element
  slow: set thermo to slow (i.e., nondecreasing vs. increasing), defaults to False, can also use setSlowOddEvenThermo
  missing: set thermo to have missing bulb, so increase may start from either end; Optional: defaults to False.
  
setSlowOddEvenThermo(list): asserts that the values in cells do not decrease from the beginning of the line to the end, and all have the same parity
  list: list of cell specifications, with bulb end of thermo being the first element
  
setMissingThermo(list,slow): asserts that the values increase from one end of the thermo to the other, but which end is which is not determined
  list: list of cell specifications, with bulb end of thermo being the first element
  slow: set thermo to slow (i.e., nondecreasing vs. increasing); Optional: defaults to False
  
Triple Tabs
-----------
setTripleTab(row,col,uldr,digits,cellCount): sets a triple tab clue, which is like an Outside clue, but appears inside the grid and is based at a cell
	row,col: the cell where the clue is placed
	uldr: defines the direction the clue points from the base cell. Use class variables Up, Down, Left, Right
	digits: a list of digits that must appear in the direction pointed by the tab
	cellCount: the number of cells from the base cell in which the given digits must appear (Default: 3)

Unicorn Digits
--------------
setUnicornDigit(value): set a unicorn digit, i.e. for any instance of that digit in the grid, all of the cells a knight's move away have distinct values
	value: value of the digit to be a unicorn

Up and Down Lines
-----------------
setUpAndDownLine(inlist): sets an up and down line constraint; cells must alternately increase and decrease
  inlist: list of cell specifications
  
Weak Palindrome Lines
---------------------
setWeakPalindromeLine(list): creates a weak palindrome line constraint: instead of matching digits, palindromic positions must match on parity and magnitude (1-4 vs. 5-9)
  list: a list of cell specifications
  
Whispers Lines
--------------
setMinWhispersLine(inlist,value): asserts two adjacent cells on a line have a difference of at least value
	inlist: list of cell specifications
	value: integer

setMaxWhispersLine(inlist,value): asserts two adjacent cells on a line have a difference of at most value
	inlist: list of cell specifications
	value: integer
	
setChineseWhispersLine(inlist): two adjacent cells on a line have a difference of at most 2
	inlist: list of cell specifications
	
setDutchWhispersLine(inlist): two adjacent cells on a line have a difference of at least 4
	inlist: list of cell specifications
	
setGermanWhispersLine(inlist): two adjacent cells on a line have a difference of at least 5
	inlist: list of cell specifications

Windoku
-------
setWindoku(): assert Windoku rules

X-Kropki
--------
setXKropki(row,col,rc,wb,neg): The first cell next to the Kropki dot (outside the grid) indicates the position (0-7) of the corresponding Kropki dot in the row/column. Designed by Zegres.
  row,col: coordinates of the cell next to the clue
  rc: indicates whether rule applies to row or column. Use Row and Col class variables
  wb: indicates whether Kropki clue is white or black. Use White and Black class variables
  neg (optional, default False): If true, indicates that there are no other Kropki relationships of the same color in the row/column
  
XSudoku
-------
setXSudokuMain(): assert no repeats on the main (top left to bottom right) diagonal

setXSudokuOff(): assert no repeats on the off (top right to bottom left) diagonal

setBentDiagonals(): assert no repeats on the bent diagonals between adjacent corners through the center box

setAntiDiagonalMain(): assert that the main diagonal contains the minimum number of digits possible (3 for normal sudoku)

setAntiDiagonalOff(): assert that the off diagonal contains the minimum number of digits possible (3 for normal sudoku)

X-Sums
------
setXSum(row,col,rc,value): set an X sum constraint on a row or column
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells in the row/column from the clue, where X is the value in the adjacent cell
  Note: for negative digits, the behavior of an X-Sum is to take digits from the other side of the row/column, a la a reverse sum
  
setReverseXSum(row,col,rc,value): set a reverse X sum constraint on a row or column, where the sum is taken on cells starting from the end of the row/column opposite the clue
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells on the other side of the row/column from the clue, where X is the value in the adjacent cell
  Note: for negative digits, the behavior of a Reverse X-Sum is to take digits from the other side of the row/column, a la regular X-Sum
  
setDoubleXSum(row,col,rc,value): set a double X sum constraint on a row or column, where the clue is the sum of the X sums taken from both sides of the row/column
  row,col: The coordinates of the cell next to which the clue value sits
  rc: Indicates whether the clue applies to the row or column; use the Row or Column class variables
  value: The sum of the first X cells in the row/column from the clue, where X is the value in the adjacent cell, plus the sum of the first Y cells in the row/column on the other side of the row/column from the clue, where Y is the value in the cell furthest from the clue.
  Note: for negative digits, the behavior of either of the sums in a double sum is exactly as in X-sums, to take the sum from the other side
  
XV/XV Pairs
-----------
setXVV(cellHV): creates a V clue
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a V clue on the bottom edge of cell 2,5
  
setXVX(cellHV): creates an X clue
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify an X clue on the bottom edge of cell 2,5
  
setXVVArray(list): creates multiple V clues
  list: list of cellHV specifications, see setXVV

setXVXArray(list): creates multiple X clues
  list: list of cellHV specifications, see setXVX
  
setXVArray(list): creates multiple X/V clues
  list: list of cellHVXV specifications, which include a cell spec, the HV spec as given in setXVV, and a XV spec, specifying the type of clue. When given as a tuple, the X and V variables can be used to specify X/V clues. Shorthand is possible, with V being 0 and X 1.
  Example: 1701 incidates an X (1 XV spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.X)
  
setAntiXV(cellHV): asserts that a pair of cells cannot add to either 5 or 10
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXVArray(list): creates multiple anti-XV clues
  list: list of cellHV specifications, see setXVV

setXVNegative(): implements negative constraint

XVXV
----
setXVXVV(cellHV): creates a V clue, in XVXV rules, where sum may be 5 or 15
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a V clue on the bottom edge of cell 2,5
  
setXVXVX(cellHV): creates an X clue, in XVXV rules, where sum may be 10 or 15
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, but shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify an X clue on the bottom edge of cell 2,5
  
setXVXVVArray(list): creates multiple V clues
  list: list of cellHV specifications, see setXVV

setXVXVXArray(list): creates multiple X clues
  list: list of cellHV specifications, see setXVX
  
setXVXVArray(list): creates multiple X/V clues
  list: list of cellHVXV specifications, which include a cell spec, the HV spec as given in setXVV, and a XV spec, specifying the type of clue. When given as a tuple, the X and V variables can be used to specify X/V clues. Shorthand is possible, with V being 0 and X 1.
  Example: 1701 incidates an X (1 XV spec is fourth) on the right edge (0 HV spec is third) of cell 1,7 (17 cell spec is first). This can also be written as the tuple (1,7,p.Horz,p.X)
  
setAntiXVXV(cellHV): asserts that a pair of cells cannot add to either 5 or 10 or 15
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXVXVArray(list): creates multiple anti-XVXV clues
  list: list of cellHV specifications, see setXVXVV
  
setXVXVNegative(): implements negative constraint

Vaults
------
setVault(list): sets a vault, i.e., a region sich that no cell inside the region can appear in any cell outside, but orthogonally adjacent to any cell of the region
  list: list of cell specifications

XY-Difference Pairs
-------------------
setXYDifference(cellHV): creates an XY-difference clue, where the difference of the two cells separated by the clue equals the first cell in the row/column
  cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. All parameters can be given in a tuple, and these can use the Horz and Vert variables for the HV specification. Shorthand is possible, appending 0 to a cell spec to indicate horizontal and 1 to indicate vertical.
  Example: 251, '251' and (2,5,p.Vert) all specify a XY-difference clue on the bottom edge of cell 2,5

setAntiXYDifference(cellHV): asserts that a pair of cells cannot have difference equal to the first cell in the row/column
	cellHV: an extended cell specification which adds the hv parameter: clue is on the right side if H, or on the bottom if V. 
  
setAntiXYDifferenceArray(list): creates multiple anti-XY Difference clues
  list: list of cellHV specifications, see setXYDifference
  
setXYDifferenceNegative(): implements negative constraint

Zipper Lines
------------
setZipperLine(list): for an odd length, the sum of the cells equidistant from the ends equals the cell in the middle of the line. For an even length line, the sum of the cells equidistant from the ends is constant
  list: list of cell specifications

Zones
-----
setZone(list,values): sets a zone, i.e., a set of cells and a list of values such that each value must appear in the zone, *including repeats*
  list: list of cell specifications
  values: list of values to appear in the zone
  
Note that this method can be used to implement look-and-say cages as well, just by interpreting the clue string as a list of values, e.g. 27 becomes [7,7]